#!/usr/bin/env node

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// Read tokens
const tokensPath = path.join(__dirname, 'tokens.json')
const tokens = JSON.parse(fs.readFileSync(tokensPath, 'utf-8'))

// Helper to convert token value to CSS value
function tokenToCSSValue(value, description) {
  // If we have the original OKLCH value in description, use it
  if (description && description.startsWith('oklch(')) {
    return description
  }
  return value
}

// Generate CSS variables
function generateCSS() {
  let css = `/* Generated from design-tokens/tokens.json */
/* DO NOT EDIT THIS FILE DIRECTLY - Edit tokens.json instead */

@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {\n`

  // Add radius
  css += `  --radius: ${tokens.global.radius.base.value};\n`

  // Add light theme colors
  const lightColors = tokens.light.color
  for (const [key, token] of Object.entries(lightColors)) {
    if (typeof token === 'object' && token.value) {
      const cssKey = key.replace(/-/g, '-')
      const cssValue = tokenToCSSValue(token.value, token.description)
      css += `  --${cssKey}: ${cssValue};\n`
    } else if (typeof token === 'object') {
      // Handle nested chart colors
      for (const [subKey, subToken] of Object.entries(token)) {
        const cssKey = `${key}-${subKey}`
        const cssValue = tokenToCSSValue(subToken.value, subToken.description)
        css += `  --${cssKey}: ${cssValue};\n`
      }
    }
  }

  // Add sidebar colors (same as light theme initially)
  css += `  --sidebar: ${tokenToCSSValue(lightColors.secondary.value, lightColors.secondary.description)};\n`
  css += `  --sidebar-foreground: ${tokenToCSSValue(lightColors.foreground.value, lightColors.foreground.description)};\n`
  css += `  --sidebar-primary: ${tokenToCSSValue(lightColors.primary.value, lightColors.primary.description)};\n`
  css += `  --sidebar-primary-foreground: ${tokenToCSSValue(lightColors['primary-foreground'].value, lightColors['primary-foreground'].description)};\n`
  css += `  --sidebar-accent: ${tokenToCSSValue(lightColors.accent.value, lightColors.accent.description)};\n`
  css += `  --sidebar-accent-foreground: ${tokenToCSSValue(lightColors['accent-foreground'].value, lightColors['accent-foreground'].description)};\n`
  css += `  --sidebar-border: ${tokenToCSSValue(lightColors.border.value, lightColors.border.description)};\n`
  css += `  --sidebar-ring: ${tokenToCSSValue(lightColors.ring.value, lightColors.ring.description)};\n`

  css += '}\n\n'

  // Add dark theme
  css += '.dark {\n'
  const darkColors = tokens.dark.color
  for (const [key, token] of Object.entries(darkColors)) {
    if (typeof token === 'object' && token.value) {
      const cssKey = key.replace(/-/g, '-')
      const cssValue = tokenToCSSValue(token.value, token.description)
      css += `  --${cssKey}: ${cssValue};\n`
    } else if (typeof token === 'object') {
      // Handle nested chart colors
      for (const [subKey, subToken] of Object.entries(token)) {
        const cssKey = `${key}-${subKey}`
        const cssValue = tokenToCSSValue(subToken.value, subToken.description)
        css += `  --${cssKey}: ${cssValue};\n`
      }
    }
  }

  // Add dark sidebar colors
  css += `  --sidebar: ${tokenToCSSValue(darkColors.card.value, darkColors.card.description)};\n`
  css += `  --sidebar-foreground: ${tokenToCSSValue(darkColors.foreground.value, darkColors.foreground.description)};\n`
  css += `  --sidebar-primary: ${tokenToCSSValue(tokens.dark.color.chart['1'].value, tokens.dark.color.chart['1'].description)};\n`
  css += `  --sidebar-primary-foreground: ${tokenToCSSValue(darkColors.foreground.value, darkColors.foreground.description)};\n`
  css += `  --sidebar-accent: ${tokenToCSSValue(darkColors.accent.value, darkColors.accent.description)};\n`
  css += `  --sidebar-accent-foreground: ${tokenToCSSValue(darkColors['accent-foreground'].value, darkColors['accent-foreground'].description)};\n`
  css += `  --sidebar-border: ${tokenToCSSValue(darkColors.border.value, darkColors.border.description)};\n`
  css += `  --sidebar-ring: ${tokenToCSSValue(darkColors.ring.value, darkColors.ring.description)};\n`

  css += `}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
`

  return css
}

// Generate Figma-compatible JSON (without OKLCH descriptions for cleaner Figma import)
function generateFigmaTokens() {
  const figmaTokens = JSON.parse(JSON.stringify(tokens))

  // Remove descriptions from color tokens as they contain OKLCH values
  function cleanTokens(obj) {
    for (const key in obj) {
      if (typeof obj[key] === 'object' && obj[key] !== null) {
        if (obj[key].description && obj[key].description.startsWith('oklch(')) {
          delete obj[key].description
        }
        cleanTokens(obj[key])
      }
    }
  }

  cleanTokens(figmaTokens)
  return figmaTokens
}

// Write files
const outputDir = path.join(__dirname, '..')

// Generate index.css
const cssOutput = generateCSS()
const cssPath = path.join(outputDir, 'src', 'index.css')
fs.writeFileSync(cssPath, cssOutput, 'utf-8')
console.log(`âœ… Generated: ${cssPath}`)

// Generate Figma tokens
const figmaTokens = generateFigmaTokens()
const figmaTokensPath = path.join(__dirname, 'tokens.figma.json')
fs.writeFileSync(figmaTokensPath, JSON.stringify(figmaTokens, null, 2), 'utf-8')
console.log(`âœ… Generated: ${figmaTokensPath}`)

console.log('\nðŸ“¦ Token build complete!')
console.log('- CSS variables updated in src/index.css')
console.log('- Figma tokens ready in design-tokens/tokens.figma.json')
