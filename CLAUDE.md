# Instructions for Claude

## Important Guidelines
- **Test Files**: Always delete test files after testing functionality. Never leave test scripts in the codebase.
- **Demo Components**: Remove demo/example components after verifying they work.
- **Environment Variables**: NEVER use default values with environment variables
  - Bad: `process.env.API_URL || 'http://localhost:8000'` or `import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000'`
  - Good: Throw an error if the environment variable is missing
  - This ensures configuration is explicit and prevents accidental connections to wrong environments

## Frontend API Call Conventions
- **NEVER use hardcoded URLs**: All API calls must use React Query hooks generated by Orval
  - Bad: `fetch('http://localhost:8000/auth/login', ...)`
  - Good: `const { data } = await loginMutation.mutateAsync({ ... })`
- **Use generated hooks from Orval**: Located in `src/generated/` directory
  - Import hooks like: `import { useSignup, useAuthenticatePassword } from '@/generated/auth/auth'`
  - Use mutations for POST/PUT/DELETE: `const signupMutation = useSignup()`
  - Use queries for GET: `const { data } = useGetUser(userId)`
- **ALWAYS use useApiError with mutations**: Handle errors properly for user feedback
  ```tsx
  import { useApiError } from '@/hooks/useApiError'
  
  function MyComponent() {
    const { setError, clearError, ErrorAlert } = useApiError()
    const mutation = useSomeMutation()
    
    const handleSubmit = async () => {
      clearError()
      try {
        await mutation.mutateAsync(data)
        // success handling
      } catch (err) {
        setError(err) // This will display the backend's user-friendly message
      }
    }
    
    return (
      <>
        {ErrorAlert}  {/* Display error message to user */}
        {/* rest of component */}
      </>
    )
  }
  ```
- **Regenerate after backend changes**: Run `npm run generate` after any backend API changes
  - This ensures TypeScript types stay in sync with the backend
  - Generated code provides full type safety for request/response payloads
- **React Query benefits**: Automatic caching, error handling, and loading states
  - No need to manually manage loading/error states
  - Built-in retry logic and background refetching
  - Optimistic updates and cache invalidation

## Frontend File Naming Conventions
- **Views** (components used in routes): PascalCase - `HomePage.tsx`, `LoginPage.tsx`
  - Located in `src/views/`
  - Export named functions: `export function HomePage()`
- **Components**: PascalCase - `WebSocketExample.tsx`, `UserCard.tsx`  
  - Located in `src/components/`
- **Contexts**: PascalCase - `AuthContext.tsx`, `ThemeContext.tsx`
  - Located in `src/contexts/`
- **Hooks**: camelCase - `useAuth.ts`, `useApiError.tsx`
  - Located in `src/hooks/`
  - Use `.tsx` if returning JSX, `.ts` otherwise
- **UI Components** (shadcn): lowercase - `button.tsx`, `alert.tsx`
  - Located in `src/components/ui/`
  - This follows shadcn convention
- **Routes**: lowercase with dots/underscores - `login.tsx`, `auth.callback.tsx`
  - Located in `src/routes/`
  - TanStack Router requirement for file-based routing
  - Routes should ONLY contain route configuration, import components from `views/`

## Frontend Navigation Conventions
- **NEVER use hardcoded hrefs**: Always use TanStack Router's type-safe navigation
  - Bad: `<a href="/login">Login</a>`
  - Good: `<Link to="/login">Login</Link>`
- **Import Link from TanStack Router**: `import { Link } from '@tanstack/react-router'`
- **For programmatic navigation**: Use `useNavigate()` hook
  ```tsx
  const navigate = useNavigate()
  navigate({ to: '/dashboard' })
  ```
- **With route parameters**:
  ```tsx
  <Link to="/user/$userId" params={{ userId: '123' }}>View User</Link>
  navigate({ to: '/user/$userId', params: { userId: '123' } })
  ```
- **Benefits**: Type safety, auto-completion, refactoring support, prevents broken links

## Frontend Route Structure
- **Route files are minimal**: Only contain route definition and import from views
  ```tsx
  // routes/login.tsx
  import { createFileRoute } from '@tanstack/react-router'
  import { LoginPage } from '@/views/LoginPage'
  
  export const Route = createFileRoute('/login')({
    component: LoginPage,
  })
  ```
- **View components contain logic**: All component code lives in `src/views/`
- **This separation ensures**: Clean routes, reusable components, better testing

## Frontend Form Conventions
- **ALWAYS use SuperFormProvider**: All forms must use SuperFormProvider
  - Example:
    ```tsx
    const apiError = useApiError()
    
    return (
      <>
        {apiError.ErrorAlert}
        
        <SuperFormProvider
          config={{
            resolver: zodResolver(schema),
            defaultValues: { /* ... */ },
          }}
          apiError={apiError}  // Pass apiError for automatic error handling
          onSubmit={async (data) => {
            // Just throw errors - SuperFormProvider handles them
            await mutation.mutateAsync(data)
          }}
        >
          {(form) => (
            <>
              <SuperField name="email" errorText={form.formState.errors.email?.message}>
                <Input {...form.register('email')} />
              </SuperField>
              <SuperButton type="submit">Submit</SuperButton>
            </>
          )}
        </SuperFormProvider>
      </>
    )
    ```
- **Always use SuperField**: Wrap all form inputs with SuperField
  - Use `isRequired` ONLY if less than 50% of fields are required (shows red asterisk)
  - Use `isOptional` ONLY if less than 50% of fields are optional (shows "(optional)")
  - If most fields have the same requirement, don't mark them (cleaner UI)
- **Always use SuperButton**: Use SuperButton for all buttons
- **Never disable submit buttons**: Let users click submit and show validation errors

## Frontend Component Conventions
- **ALWAYS use SuperField for form fields**: Never use raw Input/Select/Textarea components directly
  - Import: `import { SuperField } from '@/components/SuperField'`
  - Provides consistent label, helper text, error text, and required indicator
  - Example:
    ```tsx
    <SuperField 
      label="Email" 
      name="email"
      isRequired
      helperText="We'll never share your email"
      errorText={errors.email?.message}
    >
      <Input {...register('email')} />
    </SuperField>
    ```
  - Features:
    - `name`: Sets form field name for proper FormData submission
    - `isRequired`: Shows red asterisk and adds aria-required
    - `helperText`: Shows helpful description below field
    - `helperIcon`: Shows info icon with tooltip instead of inline helper text
    - `errorText`: Shows validation errors with proper ARIA attributes
  - **Accessibility Features (Automatic)**:
    - Generates unique IDs for label association
    - Adds `aria-invalid` when field has errors
    - Adds `aria-describedby` linking errors/descriptions to input
    - Adds `aria-required` for required fields
    - Sets proper `name` attribute for form submission
- **ALWAYS use SuperButton for buttons**: Never use raw Button component directly
  - Import: `import { SuperButton } from '@/components/SuperButton'`
  - Automatically handles loading states for async operations
  - Example:
    ```tsx
    <SuperButton 
      leftIcon={Save}
      onClick={async () => {
        await saveData() // Automatically shows spinner
      }}
    >
      Save Changes
    </SuperButton>
    ```
  - Features:
    - `leftIcon`/`rightIcon`: Optional icons using Lucide icons
    - Automatic loading spinner when onClick returns a Promise
    - Disables button during loading to prevent double-clicks
    - Preserves all shadcn Button props (variant, size, etc.)

## Development Workflow
- **Always use Makefile commands**: When available, always use Makefile commands instead of running commands directly
  - Check for Makefile in the project root
  - Use `make` commands for starting servers, running tests, generating code, etc.
  - This ensures consistency and proper configuration

## Project Structure
- **Domain-based organization**: Code is organized by business domain, not technical layers
  - Each domain (e.g., `todos`) has its own folder under `src/app/`
  - Domain folders contain:
    - `constants.py` - Domain-specific constants (e.g., PK abbreviations)
    - `models.py` - SQLAlchemy models for that domain
    - `domains.py` - Pydantic domain objects (Create, Read, Update schemas)
    - `router.py` - FastAPI router for that domain's endpoints
  - The root `src/app/router.py` imports and includes all domain routers

## Python Package Conventions
- **NO INLINE IMPORTS**: Never use imports inside functions or methods unless absolutely necessary (e.g., avoiding circular imports)
  - All imports should be at the top of the file
  - Bad: `def my_function(): from src.core.user import UserService`
  - Good: Import at the top of the file
- **Package-Level Imports**: Always use package-level imports for cleaner code
  - Each package must have an `__init__.py` file that exports its public API
  - Import from the package level, not from individual modules
  - Bad: `from src.core.user.service import UserService`
  - Good: `from src.core.user import UserService`
- **Creating Package Exports**: When creating a new package, always create an `__init__.py` with:
  ```python
  # Example src/core/user/__init__.py
  from src.core.user.constants import USER_PK_ABBREV
  from src.core.user.domains import UserCreate, UserRead, UserUpdate
  from src.core.user.exceptions import UserNotFound
  from src.core.user.models import User
  from src.core.user.service import UserService
  
  __all__ = [
      'USER_PK_ABBREV',
      'User',
      'UserCreate',
      'UserRead',
      'UserUpdate',
      'UserNotFound',
      'UserService',
  ]
  ```
- **Internal vs External Imports**:
  - Within a package: Can use relative or full imports from individual modules
  - Outside the package: Always import from the package level
  - This provides better encapsulation and makes refactoring easier

## Documentation Maintenance
- **IMPORTANT**: When making any architectural changes, automatically update the relevant README files to reflect those changes
- Keep the `/frontend/README.md` focused on technical architecture only (no domain logic)
- Keep the `/backend/README.md` focused on technical architecture only (no domain logic)
- Document new patterns, libraries, or architectural decisions as they're introduced

## Logging Conventions
- **NEVER use print() statements**: Always use the logger instead
  - Bad: `print("User created")`
  - Good: `logger.info("User created", user_id=user.id)`
- **Use structured logging**: Pass data as kwargs, not in the message string
  - Bad: `logger.info(f"Created todo {todo_id} for user {user_id}")`
  - Good: `logger.info("Todo created", todo_id=todo_id, user_id=user_id)`
- **Use appropriate log levels**:
  - `logger.debug()` - Detailed diagnostic info (usually OFF in production)
  - `logger.info()` - Normal operations, business events
  - `logger.warning()` - Unexpected but handled situations
  - `logger.error()` - Something failed but app continues
  - `logger.critical()` - System is unusable
- **Log at boundaries**: When data enters/exits the system
- **Log with context**: Include relevant IDs and metadata
  ```python
  # Good examples:
  logger.info("Order placed", order_id=order.id, total=total, user_id=user_id)
  logger.warning("Rate limit approaching", user_id=user_id, requests=95, limit=100)
  logger.error("Payment failed", payment_id=payment_id, error=str(e), amount=amount)
  ```
- **Use logger.exception() for errors with traceback**:
  ```python
  try:
      process_payment()
  except Exception as e:
      logger.exception("Payment processing failed", payment_id=payment_id)
  ```
- **Context flows automatically**: The logging system tracks request_id automatically, no need to pass it

## Debugging Conventions
- **Use breakpoint() for debugging**: Never commit breakpoint() calls
  - The environment is configured with `PYTHONBREAKPOINT="pdbr.set_trace"` for rich debugging
  - Add `breakpoint()` where needed during development
  - Remove all breakpoints before committing
- **Use make shell for interactive debugging**: 
  - `make shell` provides an IPython environment with all models loaded
  - Database session available as `db.session`
  - Great for testing queries and debugging data issues
- **Never leave debug code**: Remove all debugging artifacts before committing
  - No commented-out debug code
  - No debug print statements
  - No test files left in the codebase

## Backend Exception Handling Conventions
- **Services throw domain exceptions**: Services should NEVER throw `APIException`
  - Create domain-specific exception classes that inherit from base exception types
  - Example: `EmailAlreadyExists`, `UserNotFound`, `AuthPasswordFailed`
- **Routes catch and convert to APIException**: Only routes/routers should throw `APIException`
  - Catch service exceptions and convert them to user-friendly API exceptions
  - Set appropriate HTTP status codes and user-friendly messages
  - Log technical details separately for debugging
- **Pattern Example**:
  ```python
  # In service (authentication_service.py):
  class EmailAlreadyExists(AuthException):
      pass
  
  def signup(self, email: str, ...):
      if existing_user:
          raise EmailAlreadyExists(f'User with email {email} already exists')
  
  # In router (router.py):
  try:
      return auth_service.signup(...)
  except EmailAlreadyExists as e:
      logger.error(f'Signup failed: {str(e)}')
      raise APIException(
          code=status.HTTP_400_BAD_REQUEST,
          message='An account with this email already exists'
      )
  ```

## Backend API Endpoint Conventions
- **Routes Must Be Minimal**: Routes should ONLY contain:
  - Error handling to transform service errors into API responses
  - A single service method call
  - NO business logic - all logic belongs in services
  - Example of a proper route:
    ```python
    @router.post('/signup')
    def signup(
        request: Request,
        payload: SignupPayload,
        auth_service: AuthenticationService = Depends(AuthenticationService.factory),
    ) -> Token:
        """Create a new user account"""
        ip_address = get_user_ip_address_from_request(request)
        return auth_service.signup(
            email=payload.email,
            password=payload.password,
            first_name=payload.first_name,
            last_name=payload.last_name,
            ip_address=ip_address,
        )
    ```
- **Function Naming**: Route function names must be in snake_case and match the URL endpoint in kebab-case
  - Example: `@router.get('/list-todos')` â†’ function name: `list_todos`
- **Service Method Naming**: Route function name must match the service method name being called
  - Example: `list_todos()` route calls `service.list_todos()`
- **Business Logic**: Routes must NOT contain business logic - only a single service method call
- **Route Logic**: The only logic allowed in routes is error handling to transform service errors into frontend-consumable errors
- **Response Types**: Use Python type hints for return types instead of `response_model` parameter
  - Good: `def list_todos() -> List[TodoRead]:`
  - Avoid: `@router.get('/list-todos', response_model=List[TodoRead])`
- **Client Generation**: After changing any API endpoint or domain object/schema, regenerate the frontend client:
  - Run the makefile command (check Makefile for exact command)
  - This ensures TypeScript types stay in sync with the backend API
- **Pattern Example**:
  ```python
  @router.get('/list-todos')
  def list_todos(
      todo_service: TodoService = Depends(TodoService.factory),
  ) -> List[TodoRead]:
      return todo_service.list_todos()
  ```

## Pydantic Model Conventions
- **Base Class**: All Pydantic models must inherit from `BaseDomain`
  - Example: `class TodoRead(BaseDomain):`
  - Never use `BaseModel` directly
  - Import from `src.common.base_domain`

## SQLAlchemy Model Conventions
- **Base Class**: All SQLAlchemy models must inherit from `BaseModel` with generic type parameters
  - Example: `class Todo(BaseModel[TodoRead, TodoCreate]):`
  - Import from `src.app.models.base_model`
- **Required Attributes**:
  - `__pk_abbrev__`: Use a constant from the domain's `constants.py` file
  - `__create_domain__`: Set to the CreateDomain class
  - `__read_domain__`: Set to the ReadDomain class
- **PK Abbreviation Pattern**: Define PK abbreviations as constants
  - Create a `constants.py` file in the domain folder
  - Define constant like `TODO_PK_ABBREV = "todo"`
  - Import and use in models: `__pk_abbrev__ = TODO_PK_ABBREV`
- **Domain Objects**: For each model, create corresponding Pydantic schemas:
  - `{ModelName}Create` - Schema for creating new instances (inherits from `BaseDomain`)
  - `{ModelName}Read` - Schema for reading instances (inherits from `BaseDomain`)
  - Example:
    ```python
    # In src/app/todos/constants.py
    TODO_PK_ABBREV = "todo"
    
    # In src/app/todos/domains.py
    from datetime import datetime
    from typing import Optional
    from src.common.base_domain import BaseDomain
    
    class TodoCreate(BaseDomain):
        title: str
        completed: bool = False
    
    class TodoRead(BaseDomain):
        id: str
        title: str
        completed: bool
        created_at: datetime
        modified_at: Optional[datetime]
    
    # In src/app/todos/models.py
    from src.app.models.base_model import BaseModel
    from src.app.todos.domains import TodoCreate, TodoRead
    from src.app.todos.constants import TODO_PK_ABBREV
    from sqlalchemy import String, Boolean
    from sqlalchemy.orm import mapped_column
    
    class Todo(BaseModel[TodoRead, TodoCreate]):
        __pk_abbrev__ = TODO_PK_ABBREV
        __create_domain__ = TodoCreate
        __read_domain__ = TodoRead
        
        title = mapped_column(String, nullable=False)
        completed = mapped_column(Boolean, default=False)
    ```

## Enum Conventions
- **Base Class**: All enums must inherit from `BaseEnum`
  - Example: `class TodoStatus(BaseEnum):`
  - Never use `enum.Enum` directly
  - Import from `src.common.base_enum`
  - BaseEnum provides useful methods: `has()`, `list_all()`, and proper string representation
- **No Hardcoded Strings**: Never use hardcoded strings for categorical values
  - Always create and use enums instead
  - Example: Use `TodoStatus.COMPLETED` instead of `"completed"`
  - This ensures type safety and prevents typos

## Function and Variable Naming Conventions
- **Function Names**: Always follow the format `{verb}_{domain_object_name}`
  - **Verbs**:
    - `list` - Returns a list/array of objects
    - `get` - Returns a single object (raises error if not found)
    - `get_or_none` - Returns an object or None
    - `map` - Returns a map/dict of objects
    - `create` - Creates a new object
    - `update` - Updates an existing object
    - `delete` - Deletes an object
    - `upsert` - Creates or updates an object
  - **Filter Parameters**: When filtering by a parameter, append it to the function name
    - Example: `list_todos_for_user_id(user_id: str)`
    - Example: `get_project_for_company_id(company_id: str)`
    - Example: `list_orders_for_customer_id(customer_id: str)`
- **Variable Names**:
  - **Single Objects**: Use the object name directly
    - Example: `todo` (for a Todo domain object)
    - Example: `user` (for a User domain object)
  - **Lists/Arrays**: Use the plural form
    - Example: `todos` (for a list of Todo objects)
    - Example: `users` (for a list of User objects)
  - **Maps/Dicts**: Use format `{key}_to_{object}`
    - Example: `todo_id_to_todo` (for mapping todo IDs to todo objects)
    - Example: `user_id_to_user` (for mapping user IDs to user objects)