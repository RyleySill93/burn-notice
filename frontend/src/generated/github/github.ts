/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * burn-notice API
 * API Documentation
 * OpenAPI spec version: 0.0.1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  GetGithubConnectUrlParams,
  GitHubAuthorizationUrl,
  GitHubCallbackRequest,
  GitHubConnectionStatus,
  GitHubSyncResponse,
  HTTPValidationError
} from '.././models';

import { customInstance } from '../../lib/axios-instance';




/**
 * Get GitHub OAuth authorization URL.
 * @summary Get Github Connect Url
 */
export const getGithubConnectUrl = (
    params: GetGithubConnectUrlParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<GitHubAuthorizationUrl>(
      {url: `/api/github/connect`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetGithubConnectUrlQueryKey = (params?: GetGithubConnectUrlParams,) => {
    return [
    `/api/github/connect`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetGithubConnectUrlQueryOptions = <TData = Awaited<ReturnType<typeof getGithubConnectUrl>>, TError = HTTPValidationError>(params: GetGithubConnectUrlParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGithubConnectUrl>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGithubConnectUrlQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGithubConnectUrl>>> = ({ signal }) => getGithubConnectUrl(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGithubConnectUrl>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGithubConnectUrlQueryResult = NonNullable<Awaited<ReturnType<typeof getGithubConnectUrl>>>
export type GetGithubConnectUrlQueryError = HTTPValidationError


export function useGetGithubConnectUrl<TData = Awaited<ReturnType<typeof getGithubConnectUrl>>, TError = HTTPValidationError>(
 params: GetGithubConnectUrlParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGithubConnectUrl>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGithubConnectUrl>>,
          TError,
          Awaited<ReturnType<typeof getGithubConnectUrl>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGithubConnectUrl<TData = Awaited<ReturnType<typeof getGithubConnectUrl>>, TError = HTTPValidationError>(
 params: GetGithubConnectUrlParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGithubConnectUrl>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGithubConnectUrl>>,
          TError,
          Awaited<ReturnType<typeof getGithubConnectUrl>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGithubConnectUrl<TData = Awaited<ReturnType<typeof getGithubConnectUrl>>, TError = HTTPValidationError>(
 params: GetGithubConnectUrlParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGithubConnectUrl>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Github Connect Url
 */

export function useGetGithubConnectUrl<TData = Awaited<ReturnType<typeof getGithubConnectUrl>>, TError = HTTPValidationError>(
 params: GetGithubConnectUrlParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGithubConnectUrl>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGithubConnectUrlQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Handle GitHub OAuth callback.
 * @summary Github Callback
 */
export const githubCallback = (
    gitHubCallbackRequest: GitHubCallbackRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<GitHubConnectionStatus>(
      {url: `/api/github/callback`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: gitHubCallbackRequest, signal
    },
      );
    }
  


export const getGithubCallbackMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof githubCallback>>, TError,{data: GitHubCallbackRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof githubCallback>>, TError,{data: GitHubCallbackRequest}, TContext> => {

const mutationKey = ['githubCallback'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof githubCallback>>, {data: GitHubCallbackRequest}> = (props) => {
          const {data} = props ?? {};

          return  githubCallback(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GithubCallbackMutationResult = NonNullable<Awaited<ReturnType<typeof githubCallback>>>
    export type GithubCallbackMutationBody = GitHubCallbackRequest
    export type GithubCallbackMutationError = HTTPValidationError

    /**
 * @summary Github Callback
 */
export const useGithubCallback = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof githubCallback>>, TError,{data: GitHubCallbackRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof githubCallback>>,
        TError,
        {data: GitHubCallbackRequest},
        TContext
      > => {

      const mutationOptions = getGithubCallbackMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Check GitHub connection status for an engineer.
 * @summary Get Github Status
 */
export const getGithubStatus = (
    engineerId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<GitHubConnectionStatus>(
      {url: `/api/github/status/${engineerId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetGithubStatusQueryKey = (engineerId?: string,) => {
    return [
    `/api/github/status/${engineerId}`
    ] as const;
    }

    
export const getGetGithubStatusQueryOptions = <TData = Awaited<ReturnType<typeof getGithubStatus>>, TError = HTTPValidationError>(engineerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGithubStatus>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGithubStatusQueryKey(engineerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGithubStatus>>> = ({ signal }) => getGithubStatus(engineerId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(engineerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGithubStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGithubStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getGithubStatus>>>
export type GetGithubStatusQueryError = HTTPValidationError


export function useGetGithubStatus<TData = Awaited<ReturnType<typeof getGithubStatus>>, TError = HTTPValidationError>(
 engineerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGithubStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGithubStatus>>,
          TError,
          Awaited<ReturnType<typeof getGithubStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGithubStatus<TData = Awaited<ReturnType<typeof getGithubStatus>>, TError = HTTPValidationError>(
 engineerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGithubStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGithubStatus>>,
          TError,
          Awaited<ReturnType<typeof getGithubStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGithubStatus<TData = Awaited<ReturnType<typeof getGithubStatus>>, TError = HTTPValidationError>(
 engineerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGithubStatus>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Github Status
 */

export function useGetGithubStatus<TData = Awaited<ReturnType<typeof getGithubStatus>>, TError = HTTPValidationError>(
 engineerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGithubStatus>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGithubStatusQueryOptions(engineerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Remove GitHub connection for an engineer.
 * @summary Disconnect Github
 */
export const disconnectGithub = (
    engineerId: string,
 ) => {
      
      
      return customInstance<GitHubConnectionStatus>(
      {url: `/api/github/disconnect/${engineerId}`, method: 'DELETE'
    },
      );
    }
  


export const getDisconnectGithubMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disconnectGithub>>, TError,{engineerId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof disconnectGithub>>, TError,{engineerId: string}, TContext> => {

const mutationKey = ['disconnectGithub'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof disconnectGithub>>, {engineerId: string}> = (props) => {
          const {engineerId} = props ?? {};

          return  disconnectGithub(engineerId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DisconnectGithubMutationResult = NonNullable<Awaited<ReturnType<typeof disconnectGithub>>>
    
    export type DisconnectGithubMutationError = HTTPValidationError

    /**
 * @summary Disconnect Github
 */
export const useDisconnectGithub = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disconnectGithub>>, TError,{engineerId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof disconnectGithub>>,
        TError,
        {engineerId: string},
        TContext
      > => {

      const mutationOptions = getDisconnectGithubMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Manually trigger GitHub data sync for an engineer.
 * @summary Sync Github
 */
export const syncGithub = (
    engineerId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<GitHubSyncResponse>(
      {url: `/api/github/sync/${engineerId}`, method: 'POST', signal
    },
      );
    }
  


export const getSyncGithubMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof syncGithub>>, TError,{engineerId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof syncGithub>>, TError,{engineerId: string}, TContext> => {

const mutationKey = ['syncGithub'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof syncGithub>>, {engineerId: string}> = (props) => {
          const {engineerId} = props ?? {};

          return  syncGithub(engineerId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SyncGithubMutationResult = NonNullable<Awaited<ReturnType<typeof syncGithub>>>
    
    export type SyncGithubMutationError = HTTPValidationError

    /**
 * @summary Sync Github
 */
export const useSyncGithub = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof syncGithub>>, TError,{engineerId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof syncGithub>>,
        TError,
        {engineerId: string},
        TContext
      > => {

      const mutationOptions = getSyncGithubMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    