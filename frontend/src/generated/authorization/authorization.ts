/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * Mewtwo API
 * API Documentation
 * OpenAPI spec version: 0.0.1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AccessPolicyRead,
  AccessPolicyWithRolePayload,
  AccessRoleCreate,
  AccessRoleCreateWithPolicies,
  AccessRoleRead,
  AccessRoleSummary,
  AddStaffMembershipPayload,
  CheckCustomerAdminAccess200,
  CreateCustomerAccessPolicyParams,
  CreateCustomerAccessRoleParams,
  CreateCustomerAccessRoleWithPoliciesParams,
  CreateCustomerPayload,
  CustomerDefaultRoleUpdate,
  DeleteCustomerAccessPolicyParams,
  DeleteCustomerAccessRoleParams,
  GetCustomerAccessPolicyParams,
  GetCustomerAccessRoleParams,
  GetMyLoginConfigParams,
  HTTPValidationError,
  ImpersonateUserParams,
  ListAccessPoliciesForCustomerParams,
  ListCustomerAccessRolesLegacyParams,
  ListCustomerAccessRolesParams,
  ListMembershipAssignmentsParams,
  ListPoliciesForCustomerRoleParams,
  ListResourcesByType200Item,
  ListResourcesByTypeParams,
  ListRolesForCustomerPolicyParams,
  ListStaffMembershipsForCustomerParams,
  Me,
  MembershipAssignmentRead,
  MyLoginConfig,
  PolicyRoleAssignmentUpdate,
  RoleCreateWithPolicies,
  RoleMembershipAssignmentUpdate,
  RolePolicyAssignmentUpdate,
  SearchUsersToImpersonateParams,
  Token,
  UpdateCustomerAccessPolicyParams,
  UpdateCustomerAccessRoleParams,
  UpdateCustomerDefaultRole200,
  UpdateCustomerDefaultRoleParams,
  UpdateCustomerPolicyRoleAssignments200,
  UpdateCustomerPolicyRoleAssignmentsParams,
  UpdateCustomerRolePolicyAssignments200,
  UpdateCustomerRolePolicyAssignmentsParams,
  UpdateRoleMembershipAssignmentsParams,
  UserRead
} from '.././models';

import { customInstance } from '../../lib/axios-instance';




/**
 * @summary Get Me
 */
export const getMe = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<Me>(
      {url: `/authorization/me`, method: 'GET', signal
    },
      );
    }
  



export const getGetMeQueryKey = () => {
    return [
    `/authorization/me`
    ] as const;
    }

    
export const getGetMeQueryOptions = <TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({ signal }) => getMe(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMeQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>
export type GetMeQueryError = unknown


export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Me
 */

export function useGetMe<TData = Awaited<ReturnType<typeof getMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Create a new customer for a user without any memberships.

Creates a Customer with the given name, assigns the user to a Membership,
and grants them admin access to the customer.
 * @summary Create Customer
 */
export const createCustomer = (
    createCustomerPayload: CreateCustomerPayload,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Me>(
      {url: `/authorization/create-customer`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCustomerPayload, signal
    },
      );
    }
  


export const getCreateCustomerMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomer>>, TError,{data: CreateCustomerPayload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCustomer>>, TError,{data: CreateCustomerPayload}, TContext> => {

const mutationKey = ['createCustomer'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCustomer>>, {data: CreateCustomerPayload}> = (props) => {
          const {data} = props ?? {};

          return  createCustomer(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCustomerMutationResult = NonNullable<Awaited<ReturnType<typeof createCustomer>>>
    export type CreateCustomerMutationBody = CreateCustomerPayload
    export type CreateCustomerMutationError = HTTPValidationError

    /**
 * @summary Create Customer
 */
export const useCreateCustomer = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomer>>, TError,{data: CreateCustomerPayload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCustomer>>,
        TError,
        {data: CreateCustomerPayload},
        TContext
      > => {

      const mutationOptions = getCreateCustomerMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Add Staff User
 */
export const addStaffUser = (
    addStaffMembershipPayload: AddStaffMembershipPayload,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/authorization/add-staff-user`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addStaffMembershipPayload, signal
    },
      );
    }
  


export const getAddStaffUserMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addStaffUser>>, TError,{data: AddStaffMembershipPayload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addStaffUser>>, TError,{data: AddStaffMembershipPayload}, TContext> => {

const mutationKey = ['addStaffUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addStaffUser>>, {data: AddStaffMembershipPayload}> = (props) => {
          const {data} = props ?? {};

          return  addStaffUser(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddStaffUserMutationResult = NonNullable<Awaited<ReturnType<typeof addStaffUser>>>
    export type AddStaffUserMutationBody = AddStaffMembershipPayload
    export type AddStaffUserMutationError = HTTPValidationError

    /**
 * @summary Add Staff User
 */
export const useAddStaffUser = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addStaffUser>>, TError,{data: AddStaffMembershipPayload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addStaffUser>>,
        TError,
        {data: AddStaffMembershipPayload},
        TContext
      > => {

      const mutationOptions = getAddStaffUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Fetches required login details for a user email.
If the email is invalid, it will return default login settings to
disguise implementation details of our system.
 * @summary Get My Login Config
 */
export const getMyLoginConfig = (
    params: GetMyLoginConfigParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<MyLoginConfig>(
      {url: `/authorization/my-login-config`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetMyLoginConfigQueryKey = (params?: GetMyLoginConfigParams,) => {
    return [
    `/authorization/my-login-config`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetMyLoginConfigQueryOptions = <TData = Awaited<ReturnType<typeof getMyLoginConfig>>, TError = HTTPValidationError>(params: GetMyLoginConfigParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyLoginConfig>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyLoginConfigQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyLoginConfig>>> = ({ signal }) => getMyLoginConfig(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyLoginConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMyLoginConfigQueryResult = NonNullable<Awaited<ReturnType<typeof getMyLoginConfig>>>
export type GetMyLoginConfigQueryError = HTTPValidationError


export function useGetMyLoginConfig<TData = Awaited<ReturnType<typeof getMyLoginConfig>>, TError = HTTPValidationError>(
 params: GetMyLoginConfigParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyLoginConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyLoginConfig>>,
          TError,
          Awaited<ReturnType<typeof getMyLoginConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyLoginConfig<TData = Awaited<ReturnType<typeof getMyLoginConfig>>, TError = HTTPValidationError>(
 params: GetMyLoginConfigParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyLoginConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyLoginConfig>>,
          TError,
          Awaited<ReturnType<typeof getMyLoginConfig>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyLoginConfig<TData = Awaited<ReturnType<typeof getMyLoginConfig>>, TError = HTTPValidationError>(
 params: GetMyLoginConfigParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyLoginConfig>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get My Login Config
 */

export function useGetMyLoginConfig<TData = Awaited<ReturnType<typeof getMyLoginConfig>>, TError = HTTPValidationError>(
 params: GetMyLoginConfigParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyLoginConfig>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMyLoginConfigQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Impersonate User
 */
export const impersonateUser = (
    params: ImpersonateUserParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Token>(
      {url: `/authorization/impersonate`, method: 'POST',
        params, signal
    },
      );
    }
  


export const getImpersonateUserMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof impersonateUser>>, TError,{params: ImpersonateUserParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof impersonateUser>>, TError,{params: ImpersonateUserParams}, TContext> => {

const mutationKey = ['impersonateUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof impersonateUser>>, {params: ImpersonateUserParams}> = (props) => {
          const {params} = props ?? {};

          return  impersonateUser(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImpersonateUserMutationResult = NonNullable<Awaited<ReturnType<typeof impersonateUser>>>
    
    export type ImpersonateUserMutationError = HTTPValidationError

    /**
 * @summary Impersonate User
 */
export const useImpersonateUser = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof impersonateUser>>, TError,{params: ImpersonateUserParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof impersonateUser>>,
        TError,
        {params: ImpersonateUserParams},
        TContext
      > => {

      const mutationOptions = getImpersonateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Cancel Impersonate User
 */
export const cancelImpersonateUser = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<Token>(
      {url: `/authorization/cancel-impersonate`, method: 'POST', signal
    },
      );
    }
  


export const getCancelImpersonateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelImpersonateUser>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof cancelImpersonateUser>>, TError,void, TContext> => {

const mutationKey = ['cancelImpersonateUser'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelImpersonateUser>>, void> = () => {
          

          return  cancelImpersonateUser()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancelImpersonateUserMutationResult = NonNullable<Awaited<ReturnType<typeof cancelImpersonateUser>>>
    
    export type CancelImpersonateUserMutationError = unknown

    /**
 * @summary Cancel Impersonate User
 */
export const useCancelImpersonateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelImpersonateUser>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelImpersonateUser>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCancelImpersonateUserMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Search Users To Impersonate
 */
export const searchUsersToImpersonate = (
    params: SearchUsersToImpersonateParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UserRead[]>(
      {url: `/authorization/search-users-to-impersonate`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getSearchUsersToImpersonateQueryKey = (params?: SearchUsersToImpersonateParams,) => {
    return [
    `/authorization/search-users-to-impersonate`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSearchUsersToImpersonateQueryOptions = <TData = Awaited<ReturnType<typeof searchUsersToImpersonate>>, TError = HTTPValidationError>(params: SearchUsersToImpersonateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchUsersToImpersonate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchUsersToImpersonateQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchUsersToImpersonate>>> = ({ signal }) => searchUsersToImpersonate(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchUsersToImpersonate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchUsersToImpersonateQueryResult = NonNullable<Awaited<ReturnType<typeof searchUsersToImpersonate>>>
export type SearchUsersToImpersonateQueryError = HTTPValidationError


export function useSearchUsersToImpersonate<TData = Awaited<ReturnType<typeof searchUsersToImpersonate>>, TError = HTTPValidationError>(
 params: SearchUsersToImpersonateParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchUsersToImpersonate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUsersToImpersonate>>,
          TError,
          Awaited<ReturnType<typeof searchUsersToImpersonate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchUsersToImpersonate<TData = Awaited<ReturnType<typeof searchUsersToImpersonate>>, TError = HTTPValidationError>(
 params: SearchUsersToImpersonateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchUsersToImpersonate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchUsersToImpersonate>>,
          TError,
          Awaited<ReturnType<typeof searchUsersToImpersonate>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchUsersToImpersonate<TData = Awaited<ReturnType<typeof searchUsersToImpersonate>>, TError = HTTPValidationError>(
 params: SearchUsersToImpersonateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchUsersToImpersonate>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search Users To Impersonate
 */

export function useSearchUsersToImpersonate<TData = Awaited<ReturnType<typeof searchUsersToImpersonate>>, TError = HTTPValidationError>(
 params: SearchUsersToImpersonateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchUsersToImpersonate>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchUsersToImpersonateQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary List Customer Access Roles
 */
export const listCustomerAccessRoles = (
    params: ListCustomerAccessRolesParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AccessRoleSummary[]>(
      {url: `/authorization/list-customer-access-roles`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListCustomerAccessRolesQueryKey = (params?: ListCustomerAccessRolesParams,) => {
    return [
    `/authorization/list-customer-access-roles`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListCustomerAccessRolesQueryOptions = <TData = Awaited<ReturnType<typeof listCustomerAccessRoles>>, TError = HTTPValidationError>(params: ListCustomerAccessRolesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomerAccessRoles>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListCustomerAccessRolesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listCustomerAccessRoles>>> = ({ signal }) => listCustomerAccessRoles(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listCustomerAccessRoles>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListCustomerAccessRolesQueryResult = NonNullable<Awaited<ReturnType<typeof listCustomerAccessRoles>>>
export type ListCustomerAccessRolesQueryError = HTTPValidationError


export function useListCustomerAccessRoles<TData = Awaited<ReturnType<typeof listCustomerAccessRoles>>, TError = HTTPValidationError>(
 params: ListCustomerAccessRolesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomerAccessRoles>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCustomerAccessRoles>>,
          TError,
          Awaited<ReturnType<typeof listCustomerAccessRoles>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListCustomerAccessRoles<TData = Awaited<ReturnType<typeof listCustomerAccessRoles>>, TError = HTTPValidationError>(
 params: ListCustomerAccessRolesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomerAccessRoles>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCustomerAccessRoles>>,
          TError,
          Awaited<ReturnType<typeof listCustomerAccessRoles>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListCustomerAccessRoles<TData = Awaited<ReturnType<typeof listCustomerAccessRoles>>, TError = HTTPValidationError>(
 params: ListCustomerAccessRolesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomerAccessRoles>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Customer Access Roles
 */

export function useListCustomerAccessRoles<TData = Awaited<ReturnType<typeof listCustomerAccessRoles>>, TError = HTTPValidationError>(
 params: ListCustomerAccessRolesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomerAccessRoles>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListCustomerAccessRolesQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * List access roles for a customer (legacy endpoint for backward compatibility)
 * @summary List Customer Access Roles Legacy
 */
export const listCustomerAccessRolesLegacy = (
    params: ListCustomerAccessRolesLegacyParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AccessRoleSummary[]>(
      {url: `/authorization/list-customer-access-roles-legacy`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListCustomerAccessRolesLegacyQueryKey = (params?: ListCustomerAccessRolesLegacyParams,) => {
    return [
    `/authorization/list-customer-access-roles-legacy`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListCustomerAccessRolesLegacyQueryOptions = <TData = Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>, TError = HTTPValidationError>(params: ListCustomerAccessRolesLegacyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListCustomerAccessRolesLegacyQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>> = ({ signal }) => listCustomerAccessRolesLegacy(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListCustomerAccessRolesLegacyQueryResult = NonNullable<Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>>
export type ListCustomerAccessRolesLegacyQueryError = HTTPValidationError


export function useListCustomerAccessRolesLegacy<TData = Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>, TError = HTTPValidationError>(
 params: ListCustomerAccessRolesLegacyParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>,
          TError,
          Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListCustomerAccessRolesLegacy<TData = Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>, TError = HTTPValidationError>(
 params: ListCustomerAccessRolesLegacyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>,
          TError,
          Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListCustomerAccessRolesLegacy<TData = Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>, TError = HTTPValidationError>(
 params: ListCustomerAccessRolesLegacyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Customer Access Roles Legacy
 */

export function useListCustomerAccessRolesLegacy<TData = Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>, TError = HTTPValidationError>(
 params: ListCustomerAccessRolesLegacyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listCustomerAccessRolesLegacy>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListCustomerAccessRolesLegacyQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Create Customer Access Role
 */
export const createCustomerAccessRole = (
    accessRoleCreateWithPolicies: AccessRoleCreateWithPolicies,
    params: CreateCustomerAccessRoleParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AccessRoleRead>(
      {url: `/authorization/create-customer-access-role`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: accessRoleCreateWithPolicies,
        params, signal
    },
      );
    }
  


export const getCreateCustomerAccessRoleMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomerAccessRole>>, TError,{data: AccessRoleCreateWithPolicies;params: CreateCustomerAccessRoleParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCustomerAccessRole>>, TError,{data: AccessRoleCreateWithPolicies;params: CreateCustomerAccessRoleParams}, TContext> => {

const mutationKey = ['createCustomerAccessRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCustomerAccessRole>>, {data: AccessRoleCreateWithPolicies;params: CreateCustomerAccessRoleParams}> = (props) => {
          const {data,params} = props ?? {};

          return  createCustomerAccessRole(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCustomerAccessRoleMutationResult = NonNullable<Awaited<ReturnType<typeof createCustomerAccessRole>>>
    export type CreateCustomerAccessRoleMutationBody = AccessRoleCreateWithPolicies
    export type CreateCustomerAccessRoleMutationError = HTTPValidationError

    /**
 * @summary Create Customer Access Role
 */
export const useCreateCustomerAccessRole = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomerAccessRole>>, TError,{data: AccessRoleCreateWithPolicies;params: CreateCustomerAccessRoleParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCustomerAccessRole>>,
        TError,
        {data: AccessRoleCreateWithPolicies;params: CreateCustomerAccessRoleParams},
        TContext
      > => {

      const mutationOptions = getCreateCustomerAccessRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create a new access role with initial policy assignments.

This endpoint allows creating a role and assigning it to policies in a single operation.
 * @summary Create Customer Access Role With Policies
 */
export const createCustomerAccessRoleWithPolicies = (
    roleCreateWithPolicies: RoleCreateWithPolicies,
    params: CreateCustomerAccessRoleWithPoliciesParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AccessRoleRead>(
      {url: `/authorization/roles/with-policies`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: roleCreateWithPolicies,
        params, signal
    },
      );
    }
  


export const getCreateCustomerAccessRoleWithPoliciesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomerAccessRoleWithPolicies>>, TError,{data: RoleCreateWithPolicies;params: CreateCustomerAccessRoleWithPoliciesParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCustomerAccessRoleWithPolicies>>, TError,{data: RoleCreateWithPolicies;params: CreateCustomerAccessRoleWithPoliciesParams}, TContext> => {

const mutationKey = ['createCustomerAccessRoleWithPolicies'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCustomerAccessRoleWithPolicies>>, {data: RoleCreateWithPolicies;params: CreateCustomerAccessRoleWithPoliciesParams}> = (props) => {
          const {data,params} = props ?? {};

          return  createCustomerAccessRoleWithPolicies(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCustomerAccessRoleWithPoliciesMutationResult = NonNullable<Awaited<ReturnType<typeof createCustomerAccessRoleWithPolicies>>>
    export type CreateCustomerAccessRoleWithPoliciesMutationBody = RoleCreateWithPolicies
    export type CreateCustomerAccessRoleWithPoliciesMutationError = HTTPValidationError

    /**
 * @summary Create Customer Access Role With Policies
 */
export const useCreateCustomerAccessRoleWithPolicies = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomerAccessRoleWithPolicies>>, TError,{data: RoleCreateWithPolicies;params: CreateCustomerAccessRoleWithPoliciesParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCustomerAccessRoleWithPolicies>>,
        TError,
        {data: RoleCreateWithPolicies;params: CreateCustomerAccessRoleWithPoliciesParams},
        TContext
      > => {

      const mutationOptions = getCreateCustomerAccessRoleWithPoliciesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get an access role by ID.
 * @summary Get Customer Access Role
 */
export const getCustomerAccessRole = (
    params: GetCustomerAccessRoleParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AccessRoleRead>(
      {url: `/authorization/get-customer-access-role`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetCustomerAccessRoleQueryKey = (params?: GetCustomerAccessRoleParams,) => {
    return [
    `/authorization/get-customer-access-role`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetCustomerAccessRoleQueryOptions = <TData = Awaited<ReturnType<typeof getCustomerAccessRole>>, TError = HTTPValidationError>(params: GetCustomerAccessRoleParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAccessRole>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomerAccessRoleQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomerAccessRole>>> = ({ signal }) => getCustomerAccessRole(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomerAccessRole>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomerAccessRoleQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomerAccessRole>>>
export type GetCustomerAccessRoleQueryError = HTTPValidationError


export function useGetCustomerAccessRole<TData = Awaited<ReturnType<typeof getCustomerAccessRole>>, TError = HTTPValidationError>(
 params: GetCustomerAccessRoleParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAccessRole>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerAccessRole>>,
          TError,
          Awaited<ReturnType<typeof getCustomerAccessRole>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerAccessRole<TData = Awaited<ReturnType<typeof getCustomerAccessRole>>, TError = HTTPValidationError>(
 params: GetCustomerAccessRoleParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAccessRole>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerAccessRole>>,
          TError,
          Awaited<ReturnType<typeof getCustomerAccessRole>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerAccessRole<TData = Awaited<ReturnType<typeof getCustomerAccessRole>>, TError = HTTPValidationError>(
 params: GetCustomerAccessRoleParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAccessRole>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Customer Access Role
 */

export function useGetCustomerAccessRole<TData = Awaited<ReturnType<typeof getCustomerAccessRole>>, TError = HTTPValidationError>(
 params: GetCustomerAccessRoleParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAccessRole>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomerAccessRoleQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update an access role.
 * @summary Update Customer Access Role
 */
export const updateCustomerAccessRole = (
    accessRoleCreate: AccessRoleCreate,
    params: UpdateCustomerAccessRoleParams,
 ) => {
      
      
      return customInstance<AccessRoleRead>(
      {url: `/authorization/update-customer-access-role`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: accessRoleCreate,
        params
    },
      );
    }
  


export const getUpdateCustomerAccessRoleMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomerAccessRole>>, TError,{data: AccessRoleCreate;params: UpdateCustomerAccessRoleParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCustomerAccessRole>>, TError,{data: AccessRoleCreate;params: UpdateCustomerAccessRoleParams}, TContext> => {

const mutationKey = ['updateCustomerAccessRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCustomerAccessRole>>, {data: AccessRoleCreate;params: UpdateCustomerAccessRoleParams}> = (props) => {
          const {data,params} = props ?? {};

          return  updateCustomerAccessRole(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCustomerAccessRoleMutationResult = NonNullable<Awaited<ReturnType<typeof updateCustomerAccessRole>>>
    export type UpdateCustomerAccessRoleMutationBody = AccessRoleCreate
    export type UpdateCustomerAccessRoleMutationError = HTTPValidationError

    /**
 * @summary Update Customer Access Role
 */
export const useUpdateCustomerAccessRole = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomerAccessRole>>, TError,{data: AccessRoleCreate;params: UpdateCustomerAccessRoleParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCustomerAccessRole>>,
        TError,
        {data: AccessRoleCreate;params: UpdateCustomerAccessRoleParams},
        TContext
      > => {

      const mutationOptions = getUpdateCustomerAccessRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Delete Customer Access Role
 */
export const deleteCustomerAccessRole = (
    params: DeleteCustomerAccessRoleParams,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/authorization/delete-customer-access-role`, method: 'DELETE',
        params
    },
      );
    }
  


export const getDeleteCustomerAccessRoleMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCustomerAccessRole>>, TError,{params: DeleteCustomerAccessRoleParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCustomerAccessRole>>, TError,{params: DeleteCustomerAccessRoleParams}, TContext> => {

const mutationKey = ['deleteCustomerAccessRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCustomerAccessRole>>, {params: DeleteCustomerAccessRoleParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteCustomerAccessRole(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCustomerAccessRoleMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCustomerAccessRole>>>
    
    export type DeleteCustomerAccessRoleMutationError = HTTPValidationError

    /**
 * @summary Delete Customer Access Role
 */
export const useDeleteCustomerAccessRole = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCustomerAccessRole>>, TError,{params: DeleteCustomerAccessRoleParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCustomerAccessRole>>,
        TError,
        {params: DeleteCustomerAccessRoleParams},
        TContext
      > => {

      const mutationOptions = getDeleteCustomerAccessRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List all membership assignments, optionally filtered by membership or role.
 * @summary List Membership Assignments
 */
export const listMembershipAssignments = (
    params: ListMembershipAssignmentsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<MembershipAssignmentRead[]>(
      {url: `/authorization/assignments`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListMembershipAssignmentsQueryKey = (params?: ListMembershipAssignmentsParams,) => {
    return [
    `/authorization/assignments`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListMembershipAssignmentsQueryOptions = <TData = Awaited<ReturnType<typeof listMembershipAssignments>>, TError = HTTPValidationError>(params: ListMembershipAssignmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMembershipAssignments>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListMembershipAssignmentsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listMembershipAssignments>>> = ({ signal }) => listMembershipAssignments(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listMembershipAssignments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListMembershipAssignmentsQueryResult = NonNullable<Awaited<ReturnType<typeof listMembershipAssignments>>>
export type ListMembershipAssignmentsQueryError = HTTPValidationError


export function useListMembershipAssignments<TData = Awaited<ReturnType<typeof listMembershipAssignments>>, TError = HTTPValidationError>(
 params: ListMembershipAssignmentsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMembershipAssignments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listMembershipAssignments>>,
          TError,
          Awaited<ReturnType<typeof listMembershipAssignments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListMembershipAssignments<TData = Awaited<ReturnType<typeof listMembershipAssignments>>, TError = HTTPValidationError>(
 params: ListMembershipAssignmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMembershipAssignments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listMembershipAssignments>>,
          TError,
          Awaited<ReturnType<typeof listMembershipAssignments>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListMembershipAssignments<TData = Awaited<ReturnType<typeof listMembershipAssignments>>, TError = HTTPValidationError>(
 params: ListMembershipAssignmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMembershipAssignments>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Membership Assignments
 */

export function useListMembershipAssignments<TData = Awaited<ReturnType<typeof listMembershipAssignments>>, TError = HTTPValidationError>(
 params: ListMembershipAssignmentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMembershipAssignments>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListMembershipAssignmentsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * List all policies assigned to a specific role.

Args:
    role_id: The ID of the role to get policies for
    customer_id: The ID of the customer the role belongs to

Returns:
    List of access policies assigned to the role
 * @summary List Policies For Customer Role
 */
export const listPoliciesForCustomerRole = (
    params: ListPoliciesForCustomerRoleParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AccessPolicyRead[]>(
      {url: `/authorization/list-policies-for-customer-role`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListPoliciesForCustomerRoleQueryKey = (params?: ListPoliciesForCustomerRoleParams,) => {
    return [
    `/authorization/list-policies-for-customer-role`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListPoliciesForCustomerRoleQueryOptions = <TData = Awaited<ReturnType<typeof listPoliciesForCustomerRole>>, TError = HTTPValidationError>(params: ListPoliciesForCustomerRoleParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPoliciesForCustomerRole>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPoliciesForCustomerRoleQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPoliciesForCustomerRole>>> = ({ signal }) => listPoliciesForCustomerRole(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPoliciesForCustomerRole>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPoliciesForCustomerRoleQueryResult = NonNullable<Awaited<ReturnType<typeof listPoliciesForCustomerRole>>>
export type ListPoliciesForCustomerRoleQueryError = HTTPValidationError


export function useListPoliciesForCustomerRole<TData = Awaited<ReturnType<typeof listPoliciesForCustomerRole>>, TError = HTTPValidationError>(
 params: ListPoliciesForCustomerRoleParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPoliciesForCustomerRole>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPoliciesForCustomerRole>>,
          TError,
          Awaited<ReturnType<typeof listPoliciesForCustomerRole>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPoliciesForCustomerRole<TData = Awaited<ReturnType<typeof listPoliciesForCustomerRole>>, TError = HTTPValidationError>(
 params: ListPoliciesForCustomerRoleParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPoliciesForCustomerRole>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPoliciesForCustomerRole>>,
          TError,
          Awaited<ReturnType<typeof listPoliciesForCustomerRole>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPoliciesForCustomerRole<TData = Awaited<ReturnType<typeof listPoliciesForCustomerRole>>, TError = HTTPValidationError>(
 params: ListPoliciesForCustomerRoleParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPoliciesForCustomerRole>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Policies For Customer Role
 */

export function useListPoliciesForCustomerRole<TData = Awaited<ReturnType<typeof listPoliciesForCustomerRole>>, TError = HTTPValidationError>(
 params: ListPoliciesForCustomerRoleParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPoliciesForCustomerRole>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListPoliciesForCustomerRoleQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary List Access Policies For Customer
 */
export const listAccessPoliciesForCustomer = (
    params: ListAccessPoliciesForCustomerParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AccessPolicyRead[]>(
      {url: `/authorization/list-access-policies-for-customer`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListAccessPoliciesForCustomerQueryKey = (params?: ListAccessPoliciesForCustomerParams,) => {
    return [
    `/authorization/list-access-policies-for-customer`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListAccessPoliciesForCustomerQueryOptions = <TData = Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>, TError = HTTPValidationError>(params: ListAccessPoliciesForCustomerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAccessPoliciesForCustomerQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>> = ({ signal }) => listAccessPoliciesForCustomer(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAccessPoliciesForCustomerQueryResult = NonNullable<Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>>
export type ListAccessPoliciesForCustomerQueryError = HTTPValidationError


export function useListAccessPoliciesForCustomer<TData = Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>, TError = HTTPValidationError>(
 params: ListAccessPoliciesForCustomerParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>,
          TError,
          Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAccessPoliciesForCustomer<TData = Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>, TError = HTTPValidationError>(
 params: ListAccessPoliciesForCustomerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>,
          TError,
          Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAccessPoliciesForCustomer<TData = Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>, TError = HTTPValidationError>(
 params: ListAccessPoliciesForCustomerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Access Policies For Customer
 */

export function useListAccessPoliciesForCustomer<TData = Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>, TError = HTTPValidationError>(
 params: ListAccessPoliciesForCustomerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccessPoliciesForCustomer>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListAccessPoliciesForCustomerQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * List membership IDs for users who are members of a customer via their staff role.

This endpoint is used by the UI to filter out staff users from certain operations,
such as role assignment dialogs, where staff users should be handled differently.

Args:
    customer_id: Optional ID of the customer to filter by
    access_control_service: The access control service instance
    user: The authenticated user making the request

Returns:
    A list of membership IDs belonging to staff users for the specified customer
 * @summary List Staff Memberships For Customer
 */
export const listStaffMembershipsForCustomer = (
    params: ListStaffMembershipsForCustomerParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<string[]>(
      {url: `/authorization/list-staff-memberships-for-customer`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListStaffMembershipsForCustomerQueryKey = (params?: ListStaffMembershipsForCustomerParams,) => {
    return [
    `/authorization/list-staff-memberships-for-customer`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListStaffMembershipsForCustomerQueryOptions = <TData = Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>, TError = HTTPValidationError>(params: ListStaffMembershipsForCustomerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListStaffMembershipsForCustomerQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>> = ({ signal }) => listStaffMembershipsForCustomer(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListStaffMembershipsForCustomerQueryResult = NonNullable<Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>>
export type ListStaffMembershipsForCustomerQueryError = HTTPValidationError


export function useListStaffMembershipsForCustomer<TData = Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>, TError = HTTPValidationError>(
 params: ListStaffMembershipsForCustomerParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>,
          TError,
          Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListStaffMembershipsForCustomer<TData = Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>, TError = HTTPValidationError>(
 params: ListStaffMembershipsForCustomerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>,
          TError,
          Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListStaffMembershipsForCustomer<TData = Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>, TError = HTTPValidationError>(
 params: ListStaffMembershipsForCustomerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Staff Memberships For Customer
 */

export function useListStaffMembershipsForCustomer<TData = Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>, TError = HTTPValidationError>(
 params: ListStaffMembershipsForCustomerParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listStaffMembershipsForCustomer>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListStaffMembershipsForCustomerQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Create Customer Access Policy
 */
export const createCustomerAccessPolicy = (
    accessPolicyWithRolePayload: AccessPolicyWithRolePayload,
    params: CreateCustomerAccessPolicyParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AccessPolicyRead>(
      {url: `/authorization/create-customer-access-policy`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: accessPolicyWithRolePayload,
        params, signal
    },
      );
    }
  


export const getCreateCustomerAccessPolicyMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomerAccessPolicy>>, TError,{data: AccessPolicyWithRolePayload;params: CreateCustomerAccessPolicyParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCustomerAccessPolicy>>, TError,{data: AccessPolicyWithRolePayload;params: CreateCustomerAccessPolicyParams}, TContext> => {

const mutationKey = ['createCustomerAccessPolicy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCustomerAccessPolicy>>, {data: AccessPolicyWithRolePayload;params: CreateCustomerAccessPolicyParams}> = (props) => {
          const {data,params} = props ?? {};

          return  createCustomerAccessPolicy(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCustomerAccessPolicyMutationResult = NonNullable<Awaited<ReturnType<typeof createCustomerAccessPolicy>>>
    export type CreateCustomerAccessPolicyMutationBody = AccessPolicyWithRolePayload
    export type CreateCustomerAccessPolicyMutationError = HTTPValidationError

    /**
 * @summary Create Customer Access Policy
 */
export const useCreateCustomerAccessPolicy = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCustomerAccessPolicy>>, TError,{data: AccessPolicyWithRolePayload;params: CreateCustomerAccessPolicyParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCustomerAccessPolicy>>,
        TError,
        {data: AccessPolicyWithRolePayload;params: CreateCustomerAccessPolicyParams},
        TContext
      > => {

      const mutationOptions = getCreateCustomerAccessPolicyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update role assignments for a policy.
 * @summary Update Customer Policy Role Assignments
 */
export const updateCustomerPolicyRoleAssignments = (
    policyRoleAssignmentUpdate: PolicyRoleAssignmentUpdate,
    params: UpdateCustomerPolicyRoleAssignmentsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UpdateCustomerPolicyRoleAssignments200>(
      {url: `/authorization/update-customer-policy-role-assignments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: policyRoleAssignmentUpdate,
        params, signal
    },
      );
    }
  


export const getUpdateCustomerPolicyRoleAssignmentsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomerPolicyRoleAssignments>>, TError,{data: PolicyRoleAssignmentUpdate;params: UpdateCustomerPolicyRoleAssignmentsParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCustomerPolicyRoleAssignments>>, TError,{data: PolicyRoleAssignmentUpdate;params: UpdateCustomerPolicyRoleAssignmentsParams}, TContext> => {

const mutationKey = ['updateCustomerPolicyRoleAssignments'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCustomerPolicyRoleAssignments>>, {data: PolicyRoleAssignmentUpdate;params: UpdateCustomerPolicyRoleAssignmentsParams}> = (props) => {
          const {data,params} = props ?? {};

          return  updateCustomerPolicyRoleAssignments(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCustomerPolicyRoleAssignmentsMutationResult = NonNullable<Awaited<ReturnType<typeof updateCustomerPolicyRoleAssignments>>>
    export type UpdateCustomerPolicyRoleAssignmentsMutationBody = PolicyRoleAssignmentUpdate
    export type UpdateCustomerPolicyRoleAssignmentsMutationError = HTTPValidationError

    /**
 * @summary Update Customer Policy Role Assignments
 */
export const useUpdateCustomerPolicyRoleAssignments = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomerPolicyRoleAssignments>>, TError,{data: PolicyRoleAssignmentUpdate;params: UpdateCustomerPolicyRoleAssignmentsParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCustomerPolicyRoleAssignments>>,
        TError,
        {data: PolicyRoleAssignmentUpdate;params: UpdateCustomerPolicyRoleAssignmentsParams},
        TContext
      > => {

      const mutationOptions = getUpdateCustomerPolicyRoleAssignmentsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update policy assignments for a role.
 * @summary Update Customer Role Policy Assignments
 */
export const updateCustomerRolePolicyAssignments = (
    rolePolicyAssignmentUpdate: RolePolicyAssignmentUpdate,
    params: UpdateCustomerRolePolicyAssignmentsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UpdateCustomerRolePolicyAssignments200>(
      {url: `/authorization/update-customer-role-policy-assignments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: rolePolicyAssignmentUpdate,
        params, signal
    },
      );
    }
  


export const getUpdateCustomerRolePolicyAssignmentsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomerRolePolicyAssignments>>, TError,{data: RolePolicyAssignmentUpdate;params: UpdateCustomerRolePolicyAssignmentsParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCustomerRolePolicyAssignments>>, TError,{data: RolePolicyAssignmentUpdate;params: UpdateCustomerRolePolicyAssignmentsParams}, TContext> => {

const mutationKey = ['updateCustomerRolePolicyAssignments'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCustomerRolePolicyAssignments>>, {data: RolePolicyAssignmentUpdate;params: UpdateCustomerRolePolicyAssignmentsParams}> = (props) => {
          const {data,params} = props ?? {};

          return  updateCustomerRolePolicyAssignments(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCustomerRolePolicyAssignmentsMutationResult = NonNullable<Awaited<ReturnType<typeof updateCustomerRolePolicyAssignments>>>
    export type UpdateCustomerRolePolicyAssignmentsMutationBody = RolePolicyAssignmentUpdate
    export type UpdateCustomerRolePolicyAssignmentsMutationError = HTTPValidationError

    /**
 * @summary Update Customer Role Policy Assignments
 */
export const useUpdateCustomerRolePolicyAssignments = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomerRolePolicyAssignments>>, TError,{data: RolePolicyAssignmentUpdate;params: UpdateCustomerRolePolicyAssignmentsParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCustomerRolePolicyAssignments>>,
        TError,
        {data: RolePolicyAssignmentUpdate;params: UpdateCustomerRolePolicyAssignmentsParams},
        TContext
      > => {

      const mutationOptions = getUpdateCustomerRolePolicyAssignmentsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Get Customer Access Policy
 */
export const getCustomerAccessPolicy = (
    params: GetCustomerAccessPolicyParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AccessPolicyRead>(
      {url: `/authorization/get-customer-access-policy`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetCustomerAccessPolicyQueryKey = (params?: GetCustomerAccessPolicyParams,) => {
    return [
    `/authorization/get-customer-access-policy`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetCustomerAccessPolicyQueryOptions = <TData = Awaited<ReturnType<typeof getCustomerAccessPolicy>>, TError = HTTPValidationError>(params: GetCustomerAccessPolicyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAccessPolicy>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomerAccessPolicyQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomerAccessPolicy>>> = ({ signal }) => getCustomerAccessPolicy(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomerAccessPolicy>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomerAccessPolicyQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomerAccessPolicy>>>
export type GetCustomerAccessPolicyQueryError = HTTPValidationError


export function useGetCustomerAccessPolicy<TData = Awaited<ReturnType<typeof getCustomerAccessPolicy>>, TError = HTTPValidationError>(
 params: GetCustomerAccessPolicyParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAccessPolicy>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerAccessPolicy>>,
          TError,
          Awaited<ReturnType<typeof getCustomerAccessPolicy>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerAccessPolicy<TData = Awaited<ReturnType<typeof getCustomerAccessPolicy>>, TError = HTTPValidationError>(
 params: GetCustomerAccessPolicyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAccessPolicy>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerAccessPolicy>>,
          TError,
          Awaited<ReturnType<typeof getCustomerAccessPolicy>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerAccessPolicy<TData = Awaited<ReturnType<typeof getCustomerAccessPolicy>>, TError = HTTPValidationError>(
 params: GetCustomerAccessPolicyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAccessPolicy>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Customer Access Policy
 */

export function useGetCustomerAccessPolicy<TData = Awaited<ReturnType<typeof getCustomerAccessPolicy>>, TError = HTTPValidationError>(
 params: GetCustomerAccessPolicyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAccessPolicy>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomerAccessPolicyQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Update Customer Access Policy
 */
export const updateCustomerAccessPolicy = (
    accessPolicyWithRolePayload: AccessPolicyWithRolePayload,
    params: UpdateCustomerAccessPolicyParams,
 ) => {
      
      
      return customInstance<AccessPolicyRead>(
      {url: `/authorization/update-customer-access-policy`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: accessPolicyWithRolePayload,
        params
    },
      );
    }
  


export const getUpdateCustomerAccessPolicyMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomerAccessPolicy>>, TError,{data: AccessPolicyWithRolePayload;params: UpdateCustomerAccessPolicyParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCustomerAccessPolicy>>, TError,{data: AccessPolicyWithRolePayload;params: UpdateCustomerAccessPolicyParams}, TContext> => {

const mutationKey = ['updateCustomerAccessPolicy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCustomerAccessPolicy>>, {data: AccessPolicyWithRolePayload;params: UpdateCustomerAccessPolicyParams}> = (props) => {
          const {data,params} = props ?? {};

          return  updateCustomerAccessPolicy(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCustomerAccessPolicyMutationResult = NonNullable<Awaited<ReturnType<typeof updateCustomerAccessPolicy>>>
    export type UpdateCustomerAccessPolicyMutationBody = AccessPolicyWithRolePayload
    export type UpdateCustomerAccessPolicyMutationError = HTTPValidationError

    /**
 * @summary Update Customer Access Policy
 */
export const useUpdateCustomerAccessPolicy = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomerAccessPolicy>>, TError,{data: AccessPolicyWithRolePayload;params: UpdateCustomerAccessPolicyParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCustomerAccessPolicy>>,
        TError,
        {data: AccessPolicyWithRolePayload;params: UpdateCustomerAccessPolicyParams},
        TContext
      > => {

      const mutationOptions = getUpdateCustomerAccessPolicyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Delete Customer Access Policy
 */
export const deleteCustomerAccessPolicy = (
    params: DeleteCustomerAccessPolicyParams,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/authorization/delete-customer-access-policy`, method: 'DELETE',
        params
    },
      );
    }
  


export const getDeleteCustomerAccessPolicyMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCustomerAccessPolicy>>, TError,{params: DeleteCustomerAccessPolicyParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCustomerAccessPolicy>>, TError,{params: DeleteCustomerAccessPolicyParams}, TContext> => {

const mutationKey = ['deleteCustomerAccessPolicy'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCustomerAccessPolicy>>, {params: DeleteCustomerAccessPolicyParams}> = (props) => {
          const {params} = props ?? {};

          return  deleteCustomerAccessPolicy(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCustomerAccessPolicyMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCustomerAccessPolicy>>>
    
    export type DeleteCustomerAccessPolicyMutationError = HTTPValidationError

    /**
 * @summary Delete Customer Access Policy
 */
export const useDeleteCustomerAccessPolicy = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCustomerAccessPolicy>>, TError,{params: DeleteCustomerAccessPolicyParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCustomerAccessPolicy>>,
        TError,
        {params: DeleteCustomerAccessPolicyParams},
        TContext
      > => {

      const mutationOptions = getDeleteCustomerAccessPolicyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List all roles that have a specific policy assigned.

Args:
    policy_id: The ID of the policy to get roles for
    customer_id: The ID of the customer the policy belongs to

Returns:
    List of access roles that have the specified policy assigned
 * @summary List Roles For Customer Policy
 */
export const listRolesForCustomerPolicy = (
    params: ListRolesForCustomerPolicyParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AccessRoleRead[]>(
      {url: `/authorization/list-roles-for-customer-policy`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListRolesForCustomerPolicyQueryKey = (params?: ListRolesForCustomerPolicyParams,) => {
    return [
    `/authorization/list-roles-for-customer-policy`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListRolesForCustomerPolicyQueryOptions = <TData = Awaited<ReturnType<typeof listRolesForCustomerPolicy>>, TError = HTTPValidationError>(params: ListRolesForCustomerPolicyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRolesForCustomerPolicy>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListRolesForCustomerPolicyQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listRolesForCustomerPolicy>>> = ({ signal }) => listRolesForCustomerPolicy(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listRolesForCustomerPolicy>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListRolesForCustomerPolicyQueryResult = NonNullable<Awaited<ReturnType<typeof listRolesForCustomerPolicy>>>
export type ListRolesForCustomerPolicyQueryError = HTTPValidationError


export function useListRolesForCustomerPolicy<TData = Awaited<ReturnType<typeof listRolesForCustomerPolicy>>, TError = HTTPValidationError>(
 params: ListRolesForCustomerPolicyParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRolesForCustomerPolicy>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listRolesForCustomerPolicy>>,
          TError,
          Awaited<ReturnType<typeof listRolesForCustomerPolicy>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListRolesForCustomerPolicy<TData = Awaited<ReturnType<typeof listRolesForCustomerPolicy>>, TError = HTTPValidationError>(
 params: ListRolesForCustomerPolicyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRolesForCustomerPolicy>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listRolesForCustomerPolicy>>,
          TError,
          Awaited<ReturnType<typeof listRolesForCustomerPolicy>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListRolesForCustomerPolicy<TData = Awaited<ReturnType<typeof listRolesForCustomerPolicy>>, TError = HTTPValidationError>(
 params: ListRolesForCustomerPolicyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRolesForCustomerPolicy>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Roles For Customer Policy
 */

export function useListRolesForCustomerPolicy<TData = Awaited<ReturnType<typeof listRolesForCustomerPolicy>>, TError = HTTPValidationError>(
 params: ListRolesForCustomerPolicyParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listRolesForCustomerPolicy>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListRolesForCustomerPolicyQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Update Role Membership Assignments
 */
export const updateRoleMembershipAssignments = (
    roleMembershipAssignmentUpdate: RoleMembershipAssignmentUpdate,
    params: UpdateRoleMembershipAssignmentsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/authorization/role-membership-assignments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: roleMembershipAssignmentUpdate,
        params, signal
    },
      );
    }
  


export const getUpdateRoleMembershipAssignmentsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoleMembershipAssignments>>, TError,{data: RoleMembershipAssignmentUpdate;params: UpdateRoleMembershipAssignmentsParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateRoleMembershipAssignments>>, TError,{data: RoleMembershipAssignmentUpdate;params: UpdateRoleMembershipAssignmentsParams}, TContext> => {

const mutationKey = ['updateRoleMembershipAssignments'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRoleMembershipAssignments>>, {data: RoleMembershipAssignmentUpdate;params: UpdateRoleMembershipAssignmentsParams}> = (props) => {
          const {data,params} = props ?? {};

          return  updateRoleMembershipAssignments(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRoleMembershipAssignmentsMutationResult = NonNullable<Awaited<ReturnType<typeof updateRoleMembershipAssignments>>>
    export type UpdateRoleMembershipAssignmentsMutationBody = RoleMembershipAssignmentUpdate
    export type UpdateRoleMembershipAssignmentsMutationError = HTTPValidationError

    /**
 * @summary Update Role Membership Assignments
 */
export const useUpdateRoleMembershipAssignments = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoleMembershipAssignments>>, TError,{data: RoleMembershipAssignmentUpdate;params: UpdateRoleMembershipAssignmentsParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRoleMembershipAssignments>>,
        TError,
        {data: RoleMembershipAssignmentUpdate;params: UpdateRoleMembershipAssignmentsParams},
        TContext
      > => {

      const mutationOptions = getUpdateRoleMembershipAssignmentsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List all resources of a specific type for a customer.

This endpoint returns resources that can be used in policy resource selectors.
The response format includes id and name properties for each resource.
 * @summary List Resources By Type
 */
export const listResourcesByType = (
    params: ListResourcesByTypeParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ListResourcesByType200Item[]>(
      {url: `/authorization/resources`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListResourcesByTypeQueryKey = (params?: ListResourcesByTypeParams,) => {
    return [
    `/authorization/resources`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListResourcesByTypeQueryOptions = <TData = Awaited<ReturnType<typeof listResourcesByType>>, TError = HTTPValidationError>(params: ListResourcesByTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listResourcesByType>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListResourcesByTypeQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listResourcesByType>>> = ({ signal }) => listResourcesByType(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listResourcesByType>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListResourcesByTypeQueryResult = NonNullable<Awaited<ReturnType<typeof listResourcesByType>>>
export type ListResourcesByTypeQueryError = HTTPValidationError


export function useListResourcesByType<TData = Awaited<ReturnType<typeof listResourcesByType>>, TError = HTTPValidationError>(
 params: ListResourcesByTypeParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listResourcesByType>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listResourcesByType>>,
          TError,
          Awaited<ReturnType<typeof listResourcesByType>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListResourcesByType<TData = Awaited<ReturnType<typeof listResourcesByType>>, TError = HTTPValidationError>(
 params: ListResourcesByTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listResourcesByType>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listResourcesByType>>,
          TError,
          Awaited<ReturnType<typeof listResourcesByType>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListResourcesByType<TData = Awaited<ReturnType<typeof listResourcesByType>>, TError = HTTPValidationError>(
 params: ListResourcesByTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listResourcesByType>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Resources By Type
 */

export function useListResourcesByType<TData = Awaited<ReturnType<typeof listResourcesByType>>, TError = HTTPValidationError>(
 params: ListResourcesByTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listResourcesByType>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListResourcesByTypeQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Check if the current user has admin access to a specific customer.

Admin access is granted if the user is either a staff user or
has a role with admin permissions for the customer.

Args:
    customer_id: The ID of the customer to check access for

Returns:
    A dictionary with a boolean 'has_admin_access' indicating if the user has admin access
 * @summary Check Customer Admin Access
 */
export const checkCustomerAdminAccess = (
    customerId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CheckCustomerAdminAccess200>(
      {url: `/authorization/customer/${customerId}/has-admin-access`, method: 'GET', signal
    },
      );
    }
  



export const getCheckCustomerAdminAccessQueryKey = (customerId?: string,) => {
    return [
    `/authorization/customer/${customerId}/has-admin-access`
    ] as const;
    }

    
export const getCheckCustomerAdminAccessQueryOptions = <TData = Awaited<ReturnType<typeof checkCustomerAdminAccess>>, TError = HTTPValidationError>(customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkCustomerAdminAccess>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckCustomerAdminAccessQueryKey(customerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkCustomerAdminAccess>>> = ({ signal }) => checkCustomerAdminAccess(customerId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(customerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkCustomerAdminAccess>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CheckCustomerAdminAccessQueryResult = NonNullable<Awaited<ReturnType<typeof checkCustomerAdminAccess>>>
export type CheckCustomerAdminAccessQueryError = HTTPValidationError


export function useCheckCustomerAdminAccess<TData = Awaited<ReturnType<typeof checkCustomerAdminAccess>>, TError = HTTPValidationError>(
 customerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkCustomerAdminAccess>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkCustomerAdminAccess>>,
          TError,
          Awaited<ReturnType<typeof checkCustomerAdminAccess>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckCustomerAdminAccess<TData = Awaited<ReturnType<typeof checkCustomerAdminAccess>>, TError = HTTPValidationError>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkCustomerAdminAccess>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof checkCustomerAdminAccess>>,
          TError,
          Awaited<ReturnType<typeof checkCustomerAdminAccess>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCheckCustomerAdminAccess<TData = Awaited<ReturnType<typeof checkCustomerAdminAccess>>, TError = HTTPValidationError>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkCustomerAdminAccess>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Check Customer Admin Access
 */

export function useCheckCustomerAdminAccess<TData = Awaited<ReturnType<typeof checkCustomerAdminAccess>>, TError = HTTPValidationError>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof checkCustomerAdminAccess>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCheckCustomerAdminAccessQueryOptions(customerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Update Customer Default Role
 */
export const updateCustomerDefaultRole = (
    customerDefaultRoleUpdate: CustomerDefaultRoleUpdate,
    params: UpdateCustomerDefaultRoleParams,
 ) => {
      
      
      return customInstance<UpdateCustomerDefaultRole200>(
      {url: `/authorization/update-customer-default-role`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: customerDefaultRoleUpdate,
        params
    },
      );
    }
  


export const getUpdateCustomerDefaultRoleMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomerDefaultRole>>, TError,{data: CustomerDefaultRoleUpdate;params: UpdateCustomerDefaultRoleParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCustomerDefaultRole>>, TError,{data: CustomerDefaultRoleUpdate;params: UpdateCustomerDefaultRoleParams}, TContext> => {

const mutationKey = ['updateCustomerDefaultRole'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCustomerDefaultRole>>, {data: CustomerDefaultRoleUpdate;params: UpdateCustomerDefaultRoleParams}> = (props) => {
          const {data,params} = props ?? {};

          return  updateCustomerDefaultRole(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCustomerDefaultRoleMutationResult = NonNullable<Awaited<ReturnType<typeof updateCustomerDefaultRole>>>
    export type UpdateCustomerDefaultRoleMutationBody = CustomerDefaultRoleUpdate
    export type UpdateCustomerDefaultRoleMutationError = HTTPValidationError

    /**
 * @summary Update Customer Default Role
 */
export const useUpdateCustomerDefaultRole = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomerDefaultRole>>, TError,{data: CustomerDefaultRoleUpdate;params: UpdateCustomerDefaultRoleParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCustomerDefaultRole>>,
        TError,
        {data: CustomerDefaultRoleUpdate;params: UpdateCustomerDefaultRoleParams},
        TContext
      > => {

      const mutationOptions = getUpdateCustomerDefaultRoleMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    