/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * burn-notice API
 * API Documentation
 * OpenAPI spec version: 0.0.1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AuthenticateEmailChallenge200,
  AuthenticatePassword200,
  AuthenticatedEnableSmsMfa201,
  AuthenticatedEnableSmsMfaParams,
  AuthenticatedEnableTotp201,
  AuthenticatedEnableTotpParams,
  AuthenticatedSetupSmsMfaParams,
  AuthenticationUrl,
  BodyAzureSsoCallback,
  CheckMfaCodePayload,
  DisableSmsMfa201,
  DisableTotp201,
  GetCustomerAuthSettings200,
  GetCustomerAuthSettingsDirect200,
  GetCustomerOidcProvider200,
  GetCustomerOidcProviderDirect200,
  GetCustomerOidcProviderDirectParams,
  GetCustomerOidcProviderParams,
  GetSmsStatus200,
  GetStaffOidcProvider200,
  GetTotpStatus200,
  HTTPValidationError,
  MfaChallengePayload,
  OidcCallbackParams,
  PasswordCreatePayload,
  PasswordLoginPayload,
  RefreshTokenPayload,
  SMSCodePayload,
  SMSEnablePayload,
  SMSSetupPayload,
  SMSSetupResponse,
  SaveCustomerOidcProvider200,
  SaveCustomerOidcProviderBody,
  SaveCustomerOidcProviderDirect200,
  SaveCustomerOidcProviderDirectBody,
  SaveCustomerOidcProviderDirectParams,
  SaveCustomerOidcProviderParams,
  SendSmsCode201,
  SignupPayload,
  TOTPEnablePayload,
  TOTPSetupPayload,
  TOTPSetupResponse,
  TestCustomerOidcProvider200,
  TestCustomerOidcProviderDirect200,
  TestCustomerOidcProviderDirectParams,
  TestCustomerOidcProviderParams,
  Token,
  TokenContent,
  UpdateCustomerAuthSettings200,
  UpdateCustomerAuthSettingsBody,
  UpdateCustomerAuthSettingsDirect200,
  UpdateCustomerAuthSettingsDirectBody,
  UpdatePassword201,
  UpdatePasswordParams,
  UserCreate
} from '.././models';

import { customInstance } from '../../lib/axios-instance';




/**
 * Create a new user account with email and password
 * @summary Signup
 */
export const signup = (
    signupPayload: SignupPayload,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Token>(
      {url: `/auth/signup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: signupPayload, signal
    },
      );
    }
  


export const getSignupMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError,{data: SignupPayload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError,{data: SignupPayload}, TContext> => {

const mutationKey = ['signup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signup>>, {data: SignupPayload}> = (props) => {
          const {data} = props ?? {};

          return  signup(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SignupMutationResult = NonNullable<Awaited<ReturnType<typeof signup>>>
    export type SignupMutationBody = SignupPayload
    export type SignupMutationError = HTTPValidationError

    /**
 * @summary Signup
 */
export const useSignup = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signup>>, TError,{data: SignupPayload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof signup>>,
        TError,
        {data: SignupPayload},
        TContext
      > => {

      const mutationOptions = getSignupMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Send user a login magic link email
 * @summary Generate Email Challenge
 */
export const generateEmailChallenge = (
    userCreate: UserCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/generate-email-challenge`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate, signal
    },
      );
    }
  


export const getGenerateEmailChallengeMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateEmailChallenge>>, TError,{data: UserCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof generateEmailChallenge>>, TError,{data: UserCreate}, TContext> => {

const mutationKey = ['generateEmailChallenge'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateEmailChallenge>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  generateEmailChallenge(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateEmailChallengeMutationResult = NonNullable<Awaited<ReturnType<typeof generateEmailChallenge>>>
    export type GenerateEmailChallengeMutationBody = UserCreate
    export type GenerateEmailChallengeMutationError = HTTPValidationError

    /**
 * @summary Generate Email Challenge
 */
export const useGenerateEmailChallenge = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateEmailChallenge>>, TError,{data: UserCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateEmailChallenge>>,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getGenerateEmailChallengeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Send user a initial password setup email
 * @summary Generate Setup Email
 */
export const generateSetupEmail = (
    userCreate: UserCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/generate-setup-email`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate, signal
    },
      );
    }
  


export const getGenerateSetupEmailMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateSetupEmail>>, TError,{data: UserCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof generateSetupEmail>>, TError,{data: UserCreate}, TContext> => {

const mutationKey = ['generateSetupEmail'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateSetupEmail>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  generateSetupEmail(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateSetupEmailMutationResult = NonNullable<Awaited<ReturnType<typeof generateSetupEmail>>>
    export type GenerateSetupEmailMutationBody = UserCreate
    export type GenerateSetupEmailMutationError = HTTPValidationError

    /**
 * @summary Generate Setup Email
 */
export const useGenerateSetupEmail = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateSetupEmail>>, TError,{data: UserCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateSetupEmail>>,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getGenerateSetupEmailMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Send user a password reset email
 * @summary Generate Password Reset Email
 */
export const generatePasswordResetEmail = (
    userCreate: UserCreate,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/generate-password-reset-email`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate, signal
    },
      );
    }
  


export const getGeneratePasswordResetEmailMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generatePasswordResetEmail>>, TError,{data: UserCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof generatePasswordResetEmail>>, TError,{data: UserCreate}, TContext> => {

const mutationKey = ['generatePasswordResetEmail'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generatePasswordResetEmail>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  generatePasswordResetEmail(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GeneratePasswordResetEmailMutationResult = NonNullable<Awaited<ReturnType<typeof generatePasswordResetEmail>>>
    export type GeneratePasswordResetEmailMutationBody = UserCreate
    export type GeneratePasswordResetEmailMutationError = HTTPValidationError

    /**
 * @summary Generate Password Reset Email
 */
export const useGeneratePasswordResetEmail = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generatePasswordResetEmail>>, TError,{data: UserCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generatePasswordResetEmail>>,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getGeneratePasswordResetEmailMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Authenticate email challenge
 * @summary Authenticate Email Challenge
 */
export const authenticateEmailChallenge = (
    userId: string,
    token: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticateEmailChallenge200>(
      {url: `/auth/authenticate-email-challenge/${userId}/${token}`, method: 'POST', signal
    },
      );
    }
  


export const getAuthenticateEmailChallengeMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticateEmailChallenge>>, TError,{userId: string;token: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authenticateEmailChallenge>>, TError,{userId: string;token: string}, TContext> => {

const mutationKey = ['authenticateEmailChallenge'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticateEmailChallenge>>, {userId: string;token: string}> = (props) => {
          const {userId,token} = props ?? {};

          return  authenticateEmailChallenge(userId,token,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticateEmailChallengeMutationResult = NonNullable<Awaited<ReturnType<typeof authenticateEmailChallenge>>>
    
    export type AuthenticateEmailChallengeMutationError = HTTPValidationError

    /**
 * @summary Authenticate Email Challenge
 */
export const useAuthenticateEmailChallenge = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticateEmailChallenge>>, TError,{userId: string;token: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authenticateEmailChallenge>>,
        TError,
        {userId: string;token: string},
        TContext
      > => {

      const mutationOptions = getAuthenticateEmailChallengeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * If a user has MFA enabled, this will return a MFA Token which
is part of the requirements for authenticating in authenticate_mfa
Otherwise, it will return a full Access / Refresh Token
 * @summary Authenticate Password
 */
export const authenticatePassword = (
    passwordLoginPayload: PasswordLoginPayload,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatePassword200>(
      {url: `/auth/authenticate-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: passwordLoginPayload, signal
    },
      );
    }
  


export const getAuthenticatePasswordMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticatePassword>>, TError,{data: PasswordLoginPayload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authenticatePassword>>, TError,{data: PasswordLoginPayload}, TContext> => {

const mutationKey = ['authenticatePassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticatePassword>>, {data: PasswordLoginPayload}> = (props) => {
          const {data} = props ?? {};

          return  authenticatePassword(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticatePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof authenticatePassword>>>
    export type AuthenticatePasswordMutationBody = PasswordLoginPayload
    export type AuthenticatePasswordMutationError = HTTPValidationError

    /**
 * @summary Authenticate Password
 */
export const useAuthenticatePassword = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticatePassword>>, TError,{data: PasswordLoginPayload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authenticatePassword>>,
        TError,
        {data: PasswordLoginPayload},
        TContext
      > => {

      const mutationOptions = getAuthenticatePasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get the Azure SSO login URL
 * @summary Get Azure Sso Login Url
 */
export const getAzureSsoLoginUrl = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<string>(
      {url: `/auth/azure-sso-login-url`, method: 'GET', signal
    },
      );
    }
  



export const getGetAzureSsoLoginUrlQueryKey = () => {
    return [
    `/auth/azure-sso-login-url`
    ] as const;
    }

    
export const getGetAzureSsoLoginUrlQueryOptions = <TData = Awaited<ReturnType<typeof getAzureSsoLoginUrl>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAzureSsoLoginUrl>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAzureSsoLoginUrlQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAzureSsoLoginUrl>>> = ({ signal }) => getAzureSsoLoginUrl(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAzureSsoLoginUrl>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAzureSsoLoginUrlQueryResult = NonNullable<Awaited<ReturnType<typeof getAzureSsoLoginUrl>>>
export type GetAzureSsoLoginUrlQueryError = unknown


export function useGetAzureSsoLoginUrl<TData = Awaited<ReturnType<typeof getAzureSsoLoginUrl>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAzureSsoLoginUrl>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAzureSsoLoginUrl>>,
          TError,
          Awaited<ReturnType<typeof getAzureSsoLoginUrl>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAzureSsoLoginUrl<TData = Awaited<ReturnType<typeof getAzureSsoLoginUrl>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAzureSsoLoginUrl>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAzureSsoLoginUrl>>,
          TError,
          Awaited<ReturnType<typeof getAzureSsoLoginUrl>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAzureSsoLoginUrl<TData = Awaited<ReturnType<typeof getAzureSsoLoginUrl>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAzureSsoLoginUrl>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Azure Sso Login Url
 */

export function useGetAzureSsoLoginUrl<TData = Awaited<ReturnType<typeof getAzureSsoLoginUrl>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAzureSsoLoginUrl>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAzureSsoLoginUrlQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Azure Sso Callback
 */
export const azureSsoCallback = (
    bodyAzureSsoCallback: BodyAzureSsoCallback,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/azure-sso-callback`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyAzureSsoCallback, signal
    },
      );
    }
  


export const getAzureSsoCallbackMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof azureSsoCallback>>, TError,{data: BodyAzureSsoCallback}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof azureSsoCallback>>, TError,{data: BodyAzureSsoCallback}, TContext> => {

const mutationKey = ['azureSsoCallback'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof azureSsoCallback>>, {data: BodyAzureSsoCallback}> = (props) => {
          const {data} = props ?? {};

          return  azureSsoCallback(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AzureSsoCallbackMutationResult = NonNullable<Awaited<ReturnType<typeof azureSsoCallback>>>
    export type AzureSsoCallbackMutationBody = BodyAzureSsoCallback
    export type AzureSsoCallbackMutationError = HTTPValidationError

    /**
 * @summary Azure Sso Callback
 */
export const useAzureSsoCallback = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof azureSsoCallback>>, TError,{data: BodyAzureSsoCallback}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof azureSsoCallback>>,
        TError,
        {data: BodyAzureSsoCallback},
        TContext
      > => {

      const mutationOptions = getAzureSsoCallbackMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Start OIDC flow - redirect to IDP using internal provider ID
 * @summary Initiate Oidc Login
 */
export const initiateOidcLogin = (
    providerId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticationUrl>(
      {url: `/auth/oidc/${providerId}/login`, method: 'GET', signal
    },
      );
    }
  



export const getInitiateOidcLoginQueryKey = (providerId?: string,) => {
    return [
    `/auth/oidc/${providerId}/login`
    ] as const;
    }

    
export const getInitiateOidcLoginQueryOptions = <TData = Awaited<ReturnType<typeof initiateOidcLogin>>, TError = HTTPValidationError>(providerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof initiateOidcLogin>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInitiateOidcLoginQueryKey(providerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof initiateOidcLogin>>> = ({ signal }) => initiateOidcLogin(providerId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(providerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof initiateOidcLogin>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InitiateOidcLoginQueryResult = NonNullable<Awaited<ReturnType<typeof initiateOidcLogin>>>
export type InitiateOidcLoginQueryError = HTTPValidationError


export function useInitiateOidcLogin<TData = Awaited<ReturnType<typeof initiateOidcLogin>>, TError = HTTPValidationError>(
 providerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof initiateOidcLogin>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof initiateOidcLogin>>,
          TError,
          Awaited<ReturnType<typeof initiateOidcLogin>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInitiateOidcLogin<TData = Awaited<ReturnType<typeof initiateOidcLogin>>, TError = HTTPValidationError>(
 providerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof initiateOidcLogin>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof initiateOidcLogin>>,
          TError,
          Awaited<ReturnType<typeof initiateOidcLogin>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInitiateOidcLogin<TData = Awaited<ReturnType<typeof initiateOidcLogin>>, TError = HTTPValidationError>(
 providerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof initiateOidcLogin>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Initiate Oidc Login
 */

export function useInitiateOidcLogin<TData = Awaited<ReturnType<typeof initiateOidcLogin>>, TError = HTTPValidationError>(
 providerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof initiateOidcLogin>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getInitiateOidcLoginQueryOptions(providerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Start OIDC flow using OAuth client ID - for IdP-initiated SSO flows

This endpoint is used when users come from IdP portals (Azure AD My Apps, Okta, etc.)
where we know the client_id but not the internal provider ID.

The client_id must match the OAuth client ID configured in both:
- The IdP (Azure AD, Okta, etc.)
- The OIDC provider settings in our database
 * @summary Initiate Oidc Login By Client Id
 */
export const initiateOidcLoginByClientId = (
    clientId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticationUrl>(
      {url: `/auth/oidc/initiate/${clientId}/login`, method: 'GET', signal
    },
      );
    }
  



export const getInitiateOidcLoginByClientIdQueryKey = (clientId?: string,) => {
    return [
    `/auth/oidc/initiate/${clientId}/login`
    ] as const;
    }

    
export const getInitiateOidcLoginByClientIdQueryOptions = <TData = Awaited<ReturnType<typeof initiateOidcLoginByClientId>>, TError = HTTPValidationError>(clientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof initiateOidcLoginByClientId>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInitiateOidcLoginByClientIdQueryKey(clientId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof initiateOidcLoginByClientId>>> = ({ signal }) => initiateOidcLoginByClientId(clientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(clientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof initiateOidcLoginByClientId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type InitiateOidcLoginByClientIdQueryResult = NonNullable<Awaited<ReturnType<typeof initiateOidcLoginByClientId>>>
export type InitiateOidcLoginByClientIdQueryError = HTTPValidationError


export function useInitiateOidcLoginByClientId<TData = Awaited<ReturnType<typeof initiateOidcLoginByClientId>>, TError = HTTPValidationError>(
 clientId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof initiateOidcLoginByClientId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof initiateOidcLoginByClientId>>,
          TError,
          Awaited<ReturnType<typeof initiateOidcLoginByClientId>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInitiateOidcLoginByClientId<TData = Awaited<ReturnType<typeof initiateOidcLoginByClientId>>, TError = HTTPValidationError>(
 clientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof initiateOidcLoginByClientId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof initiateOidcLoginByClientId>>,
          TError,
          Awaited<ReturnType<typeof initiateOidcLoginByClientId>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useInitiateOidcLoginByClientId<TData = Awaited<ReturnType<typeof initiateOidcLoginByClientId>>, TError = HTTPValidationError>(
 clientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof initiateOidcLoginByClientId>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Initiate Oidc Login By Client Id
 */

export function useInitiateOidcLoginByClientId<TData = Awaited<ReturnType<typeof initiateOidcLoginByClientId>>, TError = HTTPValidationError>(
 clientId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof initiateOidcLoginByClientId>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getInitiateOidcLoginByClientIdQueryOptions(clientId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Handle IDP callback
 * @summary Oidc Callback
 */
export const oidcCallback = (
    params: OidcCallbackParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Token>(
      {url: `/auth/oidc/callback`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getOidcCallbackQueryKey = (params?: OidcCallbackParams,) => {
    return [
    `/auth/oidc/callback`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getOidcCallbackQueryOptions = <TData = Awaited<ReturnType<typeof oidcCallback>>, TError = HTTPValidationError>(params: OidcCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oidcCallback>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOidcCallbackQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof oidcCallback>>> = ({ signal }) => oidcCallback(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof oidcCallback>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OidcCallbackQueryResult = NonNullable<Awaited<ReturnType<typeof oidcCallback>>>
export type OidcCallbackQueryError = HTTPValidationError


export function useOidcCallback<TData = Awaited<ReturnType<typeof oidcCallback>>, TError = HTTPValidationError>(
 params: OidcCallbackParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof oidcCallback>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof oidcCallback>>,
          TError,
          Awaited<ReturnType<typeof oidcCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOidcCallback<TData = Awaited<ReturnType<typeof oidcCallback>>, TError = HTTPValidationError>(
 params: OidcCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oidcCallback>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof oidcCallback>>,
          TError,
          Awaited<ReturnType<typeof oidcCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOidcCallback<TData = Awaited<ReturnType<typeof oidcCallback>>, TError = HTTPValidationError>(
 params: OidcCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oidcCallback>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Oidc Callback
 */

export function useOidcCallback<TData = Awaited<ReturnType<typeof oidcCallback>>, TError = HTTPValidationError>(
 params: OidcCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof oidcCallback>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOidcCallbackQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Refresh Jwt Token
 */
export const refreshJwtToken = (
    refreshTokenPayload: RefreshTokenPayload,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Token>(
      {url: `/auth/refresh`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshTokenPayload, signal
    },
      );
    }
  


export const getRefreshJwtTokenMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshJwtToken>>, TError,{data: RefreshTokenPayload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof refreshJwtToken>>, TError,{data: RefreshTokenPayload}, TContext> => {

const mutationKey = ['refreshJwtToken'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshJwtToken>>, {data: RefreshTokenPayload}> = (props) => {
          const {data} = props ?? {};

          return  refreshJwtToken(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RefreshJwtTokenMutationResult = NonNullable<Awaited<ReturnType<typeof refreshJwtToken>>>
    export type RefreshJwtTokenMutationBody = RefreshTokenPayload
    export type RefreshJwtTokenMutationError = HTTPValidationError

    /**
 * @summary Refresh Jwt Token
 */
export const useRefreshJwtToken = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshJwtToken>>, TError,{data: RefreshTokenPayload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof refreshJwtToken>>,
        TError,
        {data: RefreshTokenPayload},
        TContext
      > => {

      const mutationOptions = getRefreshJwtTokenMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get OAuth2 access token
 * @summary Introspect Token
 */
export const introspectToken = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<TokenContent>(
      {url: `/auth/introspect`, method: 'GET', signal
    },
      );
    }
  



export const getIntrospectTokenQueryKey = () => {
    return [
    `/auth/introspect`
    ] as const;
    }

    
export const getIntrospectTokenQueryOptions = <TData = Awaited<ReturnType<typeof introspectToken>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof introspectToken>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIntrospectTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof introspectToken>>> = ({ signal }) => introspectToken(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof introspectToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IntrospectTokenQueryResult = NonNullable<Awaited<ReturnType<typeof introspectToken>>>
export type IntrospectTokenQueryError = unknown


export function useIntrospectToken<TData = Awaited<ReturnType<typeof introspectToken>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof introspectToken>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof introspectToken>>,
          TError,
          Awaited<ReturnType<typeof introspectToken>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIntrospectToken<TData = Awaited<ReturnType<typeof introspectToken>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof introspectToken>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof introspectToken>>,
          TError,
          Awaited<ReturnType<typeof introspectToken>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIntrospectToken<TData = Awaited<ReturnType<typeof introspectToken>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof introspectToken>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Introspect Token
 */

export function useIntrospectToken<TData = Awaited<ReturnType<typeof introspectToken>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof introspectToken>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIntrospectTokenQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Update Password
 */
export const updatePassword = (
    passwordCreatePayload: PasswordCreatePayload,
    params: UpdatePasswordParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UpdatePassword201>(
      {url: `/auth/update-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: passwordCreatePayload,
        params, signal
    },
      );
    }
  


export const getUpdatePasswordMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePassword>>, TError,{data: PasswordCreatePayload;params: UpdatePasswordParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updatePassword>>, TError,{data: PasswordCreatePayload;params: UpdatePasswordParams}, TContext> => {

const mutationKey = ['updatePassword'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePassword>>, {data: PasswordCreatePayload;params: UpdatePasswordParams}> = (props) => {
          const {data,params} = props ?? {};

          return  updatePassword(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof updatePassword>>>
    export type UpdatePasswordMutationBody = PasswordCreatePayload
    export type UpdatePasswordMutationError = HTTPValidationError

    /**
 * @summary Update Password
 */
export const useUpdatePassword = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePassword>>, TError,{data: PasswordCreatePayload;params: UpdatePasswordParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updatePassword>>,
        TError,
        {data: PasswordCreatePayload;params: UpdatePasswordParams},
        TContext
      > => {

      const mutationOptions = getUpdatePasswordMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Generate Mfa Challenge
 */
export const generateMfaChallenge = (
    mfaChallengePayload: MfaChallengePayload,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/generate-mfa-challenge`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: mfaChallengePayload, signal
    },
      );
    }
  


export const getGenerateMfaChallengeMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateMfaChallenge>>, TError,{data: MfaChallengePayload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof generateMfaChallenge>>, TError,{data: MfaChallengePayload}, TContext> => {

const mutationKey = ['generateMfaChallenge'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateMfaChallenge>>, {data: MfaChallengePayload}> = (props) => {
          const {data} = props ?? {};

          return  generateMfaChallenge(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateMfaChallengeMutationResult = NonNullable<Awaited<ReturnType<typeof generateMfaChallenge>>>
    export type GenerateMfaChallengeMutationBody = MfaChallengePayload
    export type GenerateMfaChallengeMutationError = HTTPValidationError

    /**
 * @summary Generate Mfa Challenge
 */
export const useGenerateMfaChallenge = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateMfaChallenge>>, TError,{data: MfaChallengePayload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateMfaChallenge>>,
        TError,
        {data: MfaChallengePayload},
        TContext
      > => {

      const mutationOptions = getGenerateMfaChallengeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Authenticate Mfa
 */
export const authenticateMfa = (
    checkMfaCodePayload: CheckMfaCodePayload,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Token>(
      {url: `/auth/authenticate-mfa`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: checkMfaCodePayload, signal
    },
      );
    }
  


export const getAuthenticateMfaMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticateMfa>>, TError,{data: CheckMfaCodePayload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authenticateMfa>>, TError,{data: CheckMfaCodePayload}, TContext> => {

const mutationKey = ['authenticateMfa'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticateMfa>>, {data: CheckMfaCodePayload}> = (props) => {
          const {data} = props ?? {};

          return  authenticateMfa(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticateMfaMutationResult = NonNullable<Awaited<ReturnType<typeof authenticateMfa>>>
    export type AuthenticateMfaMutationBody = CheckMfaCodePayload
    export type AuthenticateMfaMutationError = HTTPValidationError

    /**
 * @summary Authenticate Mfa
 */
export const useAuthenticateMfa = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticateMfa>>, TError,{data: CheckMfaCodePayload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authenticateMfa>>,
        TError,
        {data: CheckMfaCodePayload},
        TContext
      > => {

      const mutationOptions = getAuthenticateMfaMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get the staff OIDC provider configuration if available.
Returns None if not configured in environment.
 * @summary Get Staff Oidc Provider
 */
export const getStaffOidcProvider = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<GetStaffOidcProvider200>(
      {url: `/auth/get-staff-oidc-provider`, method: 'GET', signal
    },
      );
    }
  



export const getGetStaffOidcProviderQueryKey = () => {
    return [
    `/auth/get-staff-oidc-provider`
    ] as const;
    }

    
export const getGetStaffOidcProviderQueryOptions = <TData = Awaited<ReturnType<typeof getStaffOidcProvider>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStaffOidcProvider>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStaffOidcProviderQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStaffOidcProvider>>> = ({ signal }) => getStaffOidcProvider(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStaffOidcProvider>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStaffOidcProviderQueryResult = NonNullable<Awaited<ReturnType<typeof getStaffOidcProvider>>>
export type GetStaffOidcProviderQueryError = unknown


export function useGetStaffOidcProvider<TData = Awaited<ReturnType<typeof getStaffOidcProvider>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStaffOidcProvider>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStaffOidcProvider>>,
          TError,
          Awaited<ReturnType<typeof getStaffOidcProvider>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStaffOidcProvider<TData = Awaited<ReturnType<typeof getStaffOidcProvider>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStaffOidcProvider>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStaffOidcProvider>>,
          TError,
          Awaited<ReturnType<typeof getStaffOidcProvider>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStaffOidcProvider<TData = Awaited<ReturnType<typeof getStaffOidcProvider>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStaffOidcProvider>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Staff Oidc Provider
 */

export function useGetStaffOidcProvider<TData = Awaited<ReturnType<typeof getStaffOidcProvider>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStaffOidcProvider>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStaffOidcProviderQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get customer authentication settings (requires customer admin permission)
 * @summary Get Customer Auth Settings
 */
export const getCustomerAuthSettings = (
    customerId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<GetCustomerAuthSettings200>(
      {url: `/auth/customer/${customerId}/auth-settings`, method: 'GET', signal
    },
      );
    }
  



export const getGetCustomerAuthSettingsQueryKey = (customerId?: string,) => {
    return [
    `/auth/customer/${customerId}/auth-settings`
    ] as const;
    }

    
export const getGetCustomerAuthSettingsQueryOptions = <TData = Awaited<ReturnType<typeof getCustomerAuthSettings>>, TError = HTTPValidationError>(customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAuthSettings>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomerAuthSettingsQueryKey(customerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomerAuthSettings>>> = ({ signal }) => getCustomerAuthSettings(customerId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(customerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomerAuthSettings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomerAuthSettingsQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomerAuthSettings>>>
export type GetCustomerAuthSettingsQueryError = HTTPValidationError


export function useGetCustomerAuthSettings<TData = Awaited<ReturnType<typeof getCustomerAuthSettings>>, TError = HTTPValidationError>(
 customerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAuthSettings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerAuthSettings>>,
          TError,
          Awaited<ReturnType<typeof getCustomerAuthSettings>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerAuthSettings<TData = Awaited<ReturnType<typeof getCustomerAuthSettings>>, TError = HTTPValidationError>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAuthSettings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerAuthSettings>>,
          TError,
          Awaited<ReturnType<typeof getCustomerAuthSettings>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerAuthSettings<TData = Awaited<ReturnType<typeof getCustomerAuthSettings>>, TError = HTTPValidationError>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAuthSettings>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Customer Auth Settings
 */

export function useGetCustomerAuthSettings<TData = Awaited<ReturnType<typeof getCustomerAuthSettings>>, TError = HTTPValidationError>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAuthSettings>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomerAuthSettingsQueryOptions(customerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update customer authentication settings (requires customer admin permission)
 * @summary Update Customer Auth Settings
 */
export const updateCustomerAuthSettings = (
    customerId: string,
    updateCustomerAuthSettingsBody: UpdateCustomerAuthSettingsBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UpdateCustomerAuthSettings200>(
      {url: `/auth/customer/${customerId}/auth-settings`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: updateCustomerAuthSettingsBody, signal
    },
      );
    }
  


export const getUpdateCustomerAuthSettingsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomerAuthSettings>>, TError,{customerId: string;data: UpdateCustomerAuthSettingsBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCustomerAuthSettings>>, TError,{customerId: string;data: UpdateCustomerAuthSettingsBody}, TContext> => {

const mutationKey = ['updateCustomerAuthSettings'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCustomerAuthSettings>>, {customerId: string;data: UpdateCustomerAuthSettingsBody}> = (props) => {
          const {customerId,data} = props ?? {};

          return  updateCustomerAuthSettings(customerId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCustomerAuthSettingsMutationResult = NonNullable<Awaited<ReturnType<typeof updateCustomerAuthSettings>>>
    export type UpdateCustomerAuthSettingsMutationBody = UpdateCustomerAuthSettingsBody
    export type UpdateCustomerAuthSettingsMutationError = HTTPValidationError

    /**
 * @summary Update Customer Auth Settings
 */
export const useUpdateCustomerAuthSettings = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomerAuthSettings>>, TError,{customerId: string;data: UpdateCustomerAuthSettingsBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCustomerAuthSettings>>,
        TError,
        {customerId: string;data: UpdateCustomerAuthSettingsBody},
        TContext
      > => {

      const mutationOptions = getUpdateCustomerAuthSettingsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get the customer's OIDC provider configuration (requires customer admin permission)
 * @summary Get Customer Oidc Provider
 */
export const getCustomerOidcProvider = (
    params: GetCustomerOidcProviderParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<GetCustomerOidcProvider200>(
      {url: `/auth/get-customer-oidc-provider`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetCustomerOidcProviderQueryKey = (params?: GetCustomerOidcProviderParams,) => {
    return [
    `/auth/get-customer-oidc-provider`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetCustomerOidcProviderQueryOptions = <TData = Awaited<ReturnType<typeof getCustomerOidcProvider>>, TError = HTTPValidationError>(params: GetCustomerOidcProviderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerOidcProvider>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomerOidcProviderQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomerOidcProvider>>> = ({ signal }) => getCustomerOidcProvider(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomerOidcProvider>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomerOidcProviderQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomerOidcProvider>>>
export type GetCustomerOidcProviderQueryError = HTTPValidationError


export function useGetCustomerOidcProvider<TData = Awaited<ReturnType<typeof getCustomerOidcProvider>>, TError = HTTPValidationError>(
 params: GetCustomerOidcProviderParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerOidcProvider>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerOidcProvider>>,
          TError,
          Awaited<ReturnType<typeof getCustomerOidcProvider>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerOidcProvider<TData = Awaited<ReturnType<typeof getCustomerOidcProvider>>, TError = HTTPValidationError>(
 params: GetCustomerOidcProviderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerOidcProvider>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerOidcProvider>>,
          TError,
          Awaited<ReturnType<typeof getCustomerOidcProvider>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerOidcProvider<TData = Awaited<ReturnType<typeof getCustomerOidcProvider>>, TError = HTTPValidationError>(
 params: GetCustomerOidcProviderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerOidcProvider>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Customer Oidc Provider
 */

export function useGetCustomerOidcProvider<TData = Awaited<ReturnType<typeof getCustomerOidcProvider>>, TError = HTTPValidationError>(
 params: GetCustomerOidcProviderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerOidcProvider>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomerOidcProviderQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Create or update customer OIDC provider configuration (requires customer admin permission)
 * @summary Save Customer Oidc Provider
 */
export const saveCustomerOidcProvider = (
    saveCustomerOidcProviderBody: SaveCustomerOidcProviderBody,
    params: SaveCustomerOidcProviderParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SaveCustomerOidcProvider200>(
      {url: `/auth/save-customer-oidc-provider`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: saveCustomerOidcProviderBody,
        params, signal
    },
      );
    }
  


export const getSaveCustomerOidcProviderMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveCustomerOidcProvider>>, TError,{data: SaveCustomerOidcProviderBody;params: SaveCustomerOidcProviderParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof saveCustomerOidcProvider>>, TError,{data: SaveCustomerOidcProviderBody;params: SaveCustomerOidcProviderParams}, TContext> => {

const mutationKey = ['saveCustomerOidcProvider'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof saveCustomerOidcProvider>>, {data: SaveCustomerOidcProviderBody;params: SaveCustomerOidcProviderParams}> = (props) => {
          const {data,params} = props ?? {};

          return  saveCustomerOidcProvider(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SaveCustomerOidcProviderMutationResult = NonNullable<Awaited<ReturnType<typeof saveCustomerOidcProvider>>>
    export type SaveCustomerOidcProviderMutationBody = SaveCustomerOidcProviderBody
    export type SaveCustomerOidcProviderMutationError = HTTPValidationError

    /**
 * @summary Save Customer Oidc Provider
 */
export const useSaveCustomerOidcProvider = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveCustomerOidcProvider>>, TError,{data: SaveCustomerOidcProviderBody;params: SaveCustomerOidcProviderParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof saveCustomerOidcProvider>>,
        TError,
        {data: SaveCustomerOidcProviderBody;params: SaveCustomerOidcProviderParams},
        TContext
      > => {

      const mutationOptions = getSaveCustomerOidcProviderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Test customer OIDC provider configuration (requires customer admin permission)
 * @summary Test Customer Oidc Provider
 */
export const testCustomerOidcProvider = (
    params: TestCustomerOidcProviderParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TestCustomerOidcProvider200>(
      {url: `/auth/test-customer-oidc-provider`, method: 'POST',
        params, signal
    },
      );
    }
  


export const getTestCustomerOidcProviderMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof testCustomerOidcProvider>>, TError,{params: TestCustomerOidcProviderParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof testCustomerOidcProvider>>, TError,{params: TestCustomerOidcProviderParams}, TContext> => {

const mutationKey = ['testCustomerOidcProvider'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof testCustomerOidcProvider>>, {params: TestCustomerOidcProviderParams}> = (props) => {
          const {params} = props ?? {};

          return  testCustomerOidcProvider(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TestCustomerOidcProviderMutationResult = NonNullable<Awaited<ReturnType<typeof testCustomerOidcProvider>>>
    
    export type TestCustomerOidcProviderMutationError = HTTPValidationError

    /**
 * @summary Test Customer Oidc Provider
 */
export const useTestCustomerOidcProvider = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof testCustomerOidcProvider>>, TError,{params: TestCustomerOidcProviderParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof testCustomerOidcProvider>>,
        TError,
        {params: TestCustomerOidcProviderParams},
        TContext
      > => {

      const mutationOptions = getTestCustomerOidcProviderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get customer authentication settings (legacy endpoint - requires customer admin permission)
 * @summary Get Customer Auth Settings Direct
 */
export const getCustomerAuthSettingsDirect = (
    customerId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<GetCustomerAuthSettingsDirect200>(
      {url: `/auth/customer/${customerId}/auth-settings-direct`, method: 'GET', signal
    },
      );
    }
  



export const getGetCustomerAuthSettingsDirectQueryKey = (customerId?: string,) => {
    return [
    `/auth/customer/${customerId}/auth-settings-direct`
    ] as const;
    }

    
export const getGetCustomerAuthSettingsDirectQueryOptions = <TData = Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>, TError = HTTPValidationError>(customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomerAuthSettingsDirectQueryKey(customerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>> = ({ signal }) => getCustomerAuthSettingsDirect(customerId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(customerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomerAuthSettingsDirectQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>>
export type GetCustomerAuthSettingsDirectQueryError = HTTPValidationError


export function useGetCustomerAuthSettingsDirect<TData = Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>, TError = HTTPValidationError>(
 customerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>,
          TError,
          Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerAuthSettingsDirect<TData = Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>, TError = HTTPValidationError>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>,
          TError,
          Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerAuthSettingsDirect<TData = Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>, TError = HTTPValidationError>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Customer Auth Settings Direct
 */

export function useGetCustomerAuthSettingsDirect<TData = Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>, TError = HTTPValidationError>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerAuthSettingsDirect>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomerAuthSettingsDirectQueryOptions(customerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Update customer authentication settings (legacy endpoint - requires customer admin permission)
 * @summary Update Customer Auth Settings Direct
 */
export const updateCustomerAuthSettingsDirect = (
    customerId: string,
    updateCustomerAuthSettingsDirectBody: UpdateCustomerAuthSettingsDirectBody,
 signal?: AbortSignal
) => {
      
      
      return customInstance<UpdateCustomerAuthSettingsDirect200>(
      {url: `/auth/customer/${customerId}/auth-settings-direct`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: updateCustomerAuthSettingsDirectBody, signal
    },
      );
    }
  


export const getUpdateCustomerAuthSettingsDirectMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomerAuthSettingsDirect>>, TError,{customerId: string;data: UpdateCustomerAuthSettingsDirectBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCustomerAuthSettingsDirect>>, TError,{customerId: string;data: UpdateCustomerAuthSettingsDirectBody}, TContext> => {

const mutationKey = ['updateCustomerAuthSettingsDirect'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCustomerAuthSettingsDirect>>, {customerId: string;data: UpdateCustomerAuthSettingsDirectBody}> = (props) => {
          const {customerId,data} = props ?? {};

          return  updateCustomerAuthSettingsDirect(customerId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCustomerAuthSettingsDirectMutationResult = NonNullable<Awaited<ReturnType<typeof updateCustomerAuthSettingsDirect>>>
    export type UpdateCustomerAuthSettingsDirectMutationBody = UpdateCustomerAuthSettingsDirectBody
    export type UpdateCustomerAuthSettingsDirectMutationError = HTTPValidationError

    /**
 * @summary Update Customer Auth Settings Direct
 */
export const useUpdateCustomerAuthSettingsDirect = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCustomerAuthSettingsDirect>>, TError,{customerId: string;data: UpdateCustomerAuthSettingsDirectBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCustomerAuthSettingsDirect>>,
        TError,
        {customerId: string;data: UpdateCustomerAuthSettingsDirectBody},
        TContext
      > => {

      const mutationOptions = getUpdateCustomerAuthSettingsDirectMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get the customer's OIDC provider configuration (legacy endpoint - requires customer admin permission)
 * @summary Get Customer Oidc Provider Direct
 */
export const getCustomerOidcProviderDirect = (
    params: GetCustomerOidcProviderDirectParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<GetCustomerOidcProviderDirect200>(
      {url: `/auth/get-customer-oidc-provider-direct`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetCustomerOidcProviderDirectQueryKey = (params?: GetCustomerOidcProviderDirectParams,) => {
    return [
    `/auth/get-customer-oidc-provider-direct`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetCustomerOidcProviderDirectQueryOptions = <TData = Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>, TError = HTTPValidationError>(params: GetCustomerOidcProviderDirectParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomerOidcProviderDirectQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>> = ({ signal }) => getCustomerOidcProviderDirect(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomerOidcProviderDirectQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>>
export type GetCustomerOidcProviderDirectQueryError = HTTPValidationError


export function useGetCustomerOidcProviderDirect<TData = Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>, TError = HTTPValidationError>(
 params: GetCustomerOidcProviderDirectParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>,
          TError,
          Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerOidcProviderDirect<TData = Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>, TError = HTTPValidationError>(
 params: GetCustomerOidcProviderDirectParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>,
          TError,
          Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerOidcProviderDirect<TData = Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>, TError = HTTPValidationError>(
 params: GetCustomerOidcProviderDirectParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Customer Oidc Provider Direct
 */

export function useGetCustomerOidcProviderDirect<TData = Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>, TError = HTTPValidationError>(
 params: GetCustomerOidcProviderDirectParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerOidcProviderDirect>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomerOidcProviderDirectQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Create or update customer OIDC provider configuration (legacy endpoint - requires customer admin permission)
 * @summary Save Customer Oidc Provider Direct
 */
export const saveCustomerOidcProviderDirect = (
    saveCustomerOidcProviderDirectBody: SaveCustomerOidcProviderDirectBody,
    params: SaveCustomerOidcProviderDirectParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SaveCustomerOidcProviderDirect200>(
      {url: `/auth/save-customer-oidc-provider-direct`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: saveCustomerOidcProviderDirectBody,
        params, signal
    },
      );
    }
  


export const getSaveCustomerOidcProviderDirectMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveCustomerOidcProviderDirect>>, TError,{data: SaveCustomerOidcProviderDirectBody;params: SaveCustomerOidcProviderDirectParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof saveCustomerOidcProviderDirect>>, TError,{data: SaveCustomerOidcProviderDirectBody;params: SaveCustomerOidcProviderDirectParams}, TContext> => {

const mutationKey = ['saveCustomerOidcProviderDirect'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof saveCustomerOidcProviderDirect>>, {data: SaveCustomerOidcProviderDirectBody;params: SaveCustomerOidcProviderDirectParams}> = (props) => {
          const {data,params} = props ?? {};

          return  saveCustomerOidcProviderDirect(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SaveCustomerOidcProviderDirectMutationResult = NonNullable<Awaited<ReturnType<typeof saveCustomerOidcProviderDirect>>>
    export type SaveCustomerOidcProviderDirectMutationBody = SaveCustomerOidcProviderDirectBody
    export type SaveCustomerOidcProviderDirectMutationError = HTTPValidationError

    /**
 * @summary Save Customer Oidc Provider Direct
 */
export const useSaveCustomerOidcProviderDirect = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveCustomerOidcProviderDirect>>, TError,{data: SaveCustomerOidcProviderDirectBody;params: SaveCustomerOidcProviderDirectParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof saveCustomerOidcProviderDirect>>,
        TError,
        {data: SaveCustomerOidcProviderDirectBody;params: SaveCustomerOidcProviderDirectParams},
        TContext
      > => {

      const mutationOptions = getSaveCustomerOidcProviderDirectMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Test customer OIDC provider configuration (legacy endpoint - requires customer admin permission)
 * @summary Test Customer Oidc Provider Direct
 */
export const testCustomerOidcProviderDirect = (
    params: TestCustomerOidcProviderDirectParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TestCustomerOidcProviderDirect200>(
      {url: `/auth/test-customer-oidc-provider-direct`, method: 'POST',
        params, signal
    },
      );
    }
  


export const getTestCustomerOidcProviderDirectMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof testCustomerOidcProviderDirect>>, TError,{params: TestCustomerOidcProviderDirectParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof testCustomerOidcProviderDirect>>, TError,{params: TestCustomerOidcProviderDirectParams}, TContext> => {

const mutationKey = ['testCustomerOidcProviderDirect'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof testCustomerOidcProviderDirect>>, {params: TestCustomerOidcProviderDirectParams}> = (props) => {
          const {params} = props ?? {};

          return  testCustomerOidcProviderDirect(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TestCustomerOidcProviderDirectMutationResult = NonNullable<Awaited<ReturnType<typeof testCustomerOidcProviderDirect>>>
    
    export type TestCustomerOidcProviderDirectMutationError = HTTPValidationError

    /**
 * @summary Test Customer Oidc Provider Direct
 */
export const useTestCustomerOidcProviderDirect = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof testCustomerOidcProviderDirect>>, TError,{params: TestCustomerOidcProviderDirectParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof testCustomerOidcProviderDirect>>,
        TError,
        {params: TestCustomerOidcProviderDirectParams},
        TContext
      > => {

      const mutationOptions = getTestCustomerOidcProviderDirectMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Generate TOTP secret during MFA setup flow.
Returns QR code and backup codes.

**Important**: User must save backup codes - they won't be shown again!

This endpoint accepts an MFA token (not a full JWT) for use during login flow.
 * @summary Generate Totp Secret
 */
export const generateTotpSecret = (
    tOTPSetupPayload: TOTPSetupPayload,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TOTPSetupResponse>(
      {url: `/auth/generate-totp-secret`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tOTPSetupPayload, signal
    },
      );
    }
  


export const getGenerateTotpSecretMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateTotpSecret>>, TError,{data: TOTPSetupPayload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof generateTotpSecret>>, TError,{data: TOTPSetupPayload}, TContext> => {

const mutationKey = ['generateTotpSecret'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateTotpSecret>>, {data: TOTPSetupPayload}> = (props) => {
          const {data} = props ?? {};

          return  generateTotpSecret(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateTotpSecretMutationResult = NonNullable<Awaited<ReturnType<typeof generateTotpSecret>>>
    export type GenerateTotpSecretMutationBody = TOTPSetupPayload
    export type GenerateTotpSecretMutationError = HTTPValidationError

    /**
 * @summary Generate Totp Secret
 */
export const useGenerateTotpSecret = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateTotpSecret>>, TError,{data: TOTPSetupPayload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateTotpSecret>>,
        TError,
        {data: TOTPSetupPayload},
        TContext
      > => {

      const mutationOptions = getGenerateTotpSecretMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Enable TOTP by verifying first code from authenticator during MFA setup flow.
This activates TOTP for the user and returns a full auth token.

Rate limited to 5 attempts - after that user must generate new secret.
This endpoint accepts an MFA token (not a full JWT) for use during login flow.
 * @summary Enable Totp
 */
export const enableTotp = (
    tOTPEnablePayload: TOTPEnablePayload,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Token>(
      {url: `/auth/enable-totp`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tOTPEnablePayload, signal
    },
      );
    }
  


export const getEnableTotpMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enableTotp>>, TError,{data: TOTPEnablePayload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof enableTotp>>, TError,{data: TOTPEnablePayload}, TContext> => {

const mutationKey = ['enableTotp'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof enableTotp>>, {data: TOTPEnablePayload}> = (props) => {
          const {data} = props ?? {};

          return  enableTotp(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EnableTotpMutationResult = NonNullable<Awaited<ReturnType<typeof enableTotp>>>
    export type EnableTotpMutationBody = TOTPEnablePayload
    export type EnableTotpMutationError = HTTPValidationError

    /**
 * @summary Enable Totp
 */
export const useEnableTotp = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enableTotp>>, TError,{data: TOTPEnablePayload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof enableTotp>>,
        TError,
        {data: TOTPEnablePayload},
        TContext
      > => {

      const mutationOptions = getEnableTotpMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Disable TOTP for authenticated user.
Requires re-authentication via password or magic link.
 * @summary Disable Totp
 */
export const disableTotp = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<DisableTotp201>(
      {url: `/auth/disable-totp`, method: 'POST', signal
    },
      );
    }
  


export const getDisableTotpMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableTotp>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof disableTotp>>, TError,void, TContext> => {

const mutationKey = ['disableTotp'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof disableTotp>>, void> = () => {
          

          return  disableTotp()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DisableTotpMutationResult = NonNullable<Awaited<ReturnType<typeof disableTotp>>>
    
    export type DisableTotpMutationError = unknown

    /**
 * @summary Disable Totp
 */
export const useDisableTotp = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableTotp>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof disableTotp>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getDisableTotpMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get TOTP status for authenticated user.
 * @summary Get Totp Status
 */
export const getTotpStatus = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<GetTotpStatus200>(
      {url: `/auth/get-totp-status`, method: 'GET', signal
    },
      );
    }
  



export const getGetTotpStatusQueryKey = () => {
    return [
    `/auth/get-totp-status`
    ] as const;
    }

    
export const getGetTotpStatusQueryOptions = <TData = Awaited<ReturnType<typeof getTotpStatus>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotpStatus>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTotpStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTotpStatus>>> = ({ signal }) => getTotpStatus(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTotpStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTotpStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getTotpStatus>>>
export type GetTotpStatusQueryError = unknown


export function useGetTotpStatus<TData = Awaited<ReturnType<typeof getTotpStatus>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotpStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotpStatus>>,
          TError,
          Awaited<ReturnType<typeof getTotpStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTotpStatus<TData = Awaited<ReturnType<typeof getTotpStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotpStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotpStatus>>,
          TError,
          Awaited<ReturnType<typeof getTotpStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTotpStatus<TData = Awaited<ReturnType<typeof getTotpStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotpStatus>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Totp Status
 */

export function useGetTotpStatus<TData = Awaited<ReturnType<typeof getTotpStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTotpStatus>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTotpStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Generate TOTP secret for authenticated user who wants to enable TOTP.
Returns QR code and backup codes.

**Important**: User must save backup codes - they won't be shown again!
 * @summary Authenticated Generate Totp Secret
 */
export const authenticatedGenerateTotpSecret = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<TOTPSetupResponse>(
      {url: `/auth/authenticated/generate-totp-secret`, method: 'POST', signal
    },
      );
    }
  


export const getAuthenticatedGenerateTotpSecretMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticatedGenerateTotpSecret>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authenticatedGenerateTotpSecret>>, TError,void, TContext> => {

const mutationKey = ['authenticatedGenerateTotpSecret'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticatedGenerateTotpSecret>>, void> = () => {
          

          return  authenticatedGenerateTotpSecret()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticatedGenerateTotpSecretMutationResult = NonNullable<Awaited<ReturnType<typeof authenticatedGenerateTotpSecret>>>
    
    export type AuthenticatedGenerateTotpSecretMutationError = unknown

    /**
 * @summary Authenticated Generate Totp Secret
 */
export const useAuthenticatedGenerateTotpSecret = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticatedGenerateTotpSecret>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authenticatedGenerateTotpSecret>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthenticatedGenerateTotpSecretMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Enable TOTP by verifying first code from authenticator for authenticated user.
This activates TOTP for the user.

Rate limited to 5 attempts - after that user must generate new secret.
 * @summary Authenticated Enable Totp
 */
export const authenticatedEnableTotp = (
    params: AuthenticatedEnableTotpParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatedEnableTotp201>(
      {url: `/auth/authenticated/enable-totp`, method: 'POST',
        params, signal
    },
      );
    }
  


export const getAuthenticatedEnableTotpMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticatedEnableTotp>>, TError,{params: AuthenticatedEnableTotpParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authenticatedEnableTotp>>, TError,{params: AuthenticatedEnableTotpParams}, TContext> => {

const mutationKey = ['authenticatedEnableTotp'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticatedEnableTotp>>, {params: AuthenticatedEnableTotpParams}> = (props) => {
          const {params} = props ?? {};

          return  authenticatedEnableTotp(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticatedEnableTotpMutationResult = NonNullable<Awaited<ReturnType<typeof authenticatedEnableTotp>>>
    
    export type AuthenticatedEnableTotpMutationError = HTTPValidationError

    /**
 * @summary Authenticated Enable Totp
 */
export const useAuthenticatedEnableTotp = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticatedEnableTotp>>, TError,{params: AuthenticatedEnableTotpParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authenticatedEnableTotp>>,
        TError,
        {params: AuthenticatedEnableTotpParams},
        TContext
      > => {

      const mutationOptions = getAuthenticatedEnableTotpMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Setup SMS MFA during MFA setup flow.
Sends verification code to provided phone number.

This endpoint accepts an MFA token (not a full JWT) for use during login flow.
 * @summary Setup Sms Mfa
 */
export const setupSmsMfa = (
    sMSSetupPayload: SMSSetupPayload,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SMSSetupResponse>(
      {url: `/auth/setup-sms-mfa`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sMSSetupPayload, signal
    },
      );
    }
  


export const getSetupSmsMfaMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setupSmsMfa>>, TError,{data: SMSSetupPayload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof setupSmsMfa>>, TError,{data: SMSSetupPayload}, TContext> => {

const mutationKey = ['setupSmsMfa'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setupSmsMfa>>, {data: SMSSetupPayload}> = (props) => {
          const {data} = props ?? {};

          return  setupSmsMfa(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SetupSmsMfaMutationResult = NonNullable<Awaited<ReturnType<typeof setupSmsMfa>>>
    export type SetupSmsMfaMutationBody = SMSSetupPayload
    export type SetupSmsMfaMutationError = HTTPValidationError

    /**
 * @summary Setup Sms Mfa
 */
export const useSetupSmsMfa = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setupSmsMfa>>, TError,{data: SMSSetupPayload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setupSmsMfa>>,
        TError,
        {data: SMSSetupPayload},
        TContext
      > => {

      const mutationOptions = getSetupSmsMfaMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Enable SMS MFA by verifying code sent via SMS during MFA setup flow.
This activates SMS MFA for the user and returns a full auth token.

Rate limited to 5 attempts - after that user must start setup again.
This endpoint accepts an MFA token (not a full JWT) for use during login flow.
 * @summary Enable Sms Mfa
 */
export const enableSmsMfa = (
    sMSEnablePayload: SMSEnablePayload,
 signal?: AbortSignal
) => {
      
      
      return customInstance<Token>(
      {url: `/auth/enable-sms-mfa`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sMSEnablePayload, signal
    },
      );
    }
  


export const getEnableSmsMfaMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enableSmsMfa>>, TError,{data: SMSEnablePayload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof enableSmsMfa>>, TError,{data: SMSEnablePayload}, TContext> => {

const mutationKey = ['enableSmsMfa'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof enableSmsMfa>>, {data: SMSEnablePayload}> = (props) => {
          const {data} = props ?? {};

          return  enableSmsMfa(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EnableSmsMfaMutationResult = NonNullable<Awaited<ReturnType<typeof enableSmsMfa>>>
    export type EnableSmsMfaMutationBody = SMSEnablePayload
    export type EnableSmsMfaMutationError = HTTPValidationError

    /**
 * @summary Enable Sms Mfa
 */
export const useEnableSmsMfa = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enableSmsMfa>>, TError,{data: SMSEnablePayload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof enableSmsMfa>>,
        TError,
        {data: SMSEnablePayload},
        TContext
      > => {

      const mutationOptions = getEnableSmsMfaMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Send SMS verification code during login flow.
This endpoint accepts an MFA token (not a full JWT).
 * @summary Send Sms Code
 */
export const sendSmsCode = (
    sMSCodePayload: SMSCodePayload,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SendSmsCode201>(
      {url: `/auth/send-sms-code`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sMSCodePayload, signal
    },
      );
    }
  


export const getSendSmsCodeMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendSmsCode>>, TError,{data: SMSCodePayload}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sendSmsCode>>, TError,{data: SMSCodePayload}, TContext> => {

const mutationKey = ['sendSmsCode'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendSmsCode>>, {data: SMSCodePayload}> = (props) => {
          const {data} = props ?? {};

          return  sendSmsCode(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendSmsCodeMutationResult = NonNullable<Awaited<ReturnType<typeof sendSmsCode>>>
    export type SendSmsCodeMutationBody = SMSCodePayload
    export type SendSmsCodeMutationError = HTTPValidationError

    /**
 * @summary Send Sms Code
 */
export const useSendSmsCode = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendSmsCode>>, TError,{data: SMSCodePayload}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendSmsCode>>,
        TError,
        {data: SMSCodePayload},
        TContext
      > => {

      const mutationOptions = getSendSmsCodeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Disable SMS MFA for authenticated user.
Requires re-authentication via password or magic link.
 * @summary Disable Sms Mfa
 */
export const disableSmsMfa = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<DisableSmsMfa201>(
      {url: `/auth/disable-sms-mfa`, method: 'POST', signal
    },
      );
    }
  


export const getDisableSmsMfaMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableSmsMfa>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof disableSmsMfa>>, TError,void, TContext> => {

const mutationKey = ['disableSmsMfa'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof disableSmsMfa>>, void> = () => {
          

          return  disableSmsMfa()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DisableSmsMfaMutationResult = NonNullable<Awaited<ReturnType<typeof disableSmsMfa>>>
    
    export type DisableSmsMfaMutationError = unknown

    /**
 * @summary Disable Sms Mfa
 */
export const useDisableSmsMfa = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disableSmsMfa>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof disableSmsMfa>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getDisableSmsMfaMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get SMS MFA status for authenticated user.
 * @summary Get Sms Status
 */
export const getSmsStatus = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<GetSmsStatus200>(
      {url: `/auth/get-sms-status`, method: 'GET', signal
    },
      );
    }
  



export const getGetSmsStatusQueryKey = () => {
    return [
    `/auth/get-sms-status`
    ] as const;
    }

    
export const getGetSmsStatusQueryOptions = <TData = Awaited<ReturnType<typeof getSmsStatus>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmsStatus>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSmsStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSmsStatus>>> = ({ signal }) => getSmsStatus(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSmsStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSmsStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getSmsStatus>>>
export type GetSmsStatusQueryError = unknown


export function useGetSmsStatus<TData = Awaited<ReturnType<typeof getSmsStatus>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmsStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSmsStatus>>,
          TError,
          Awaited<ReturnType<typeof getSmsStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSmsStatus<TData = Awaited<ReturnType<typeof getSmsStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmsStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSmsStatus>>,
          TError,
          Awaited<ReturnType<typeof getSmsStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSmsStatus<TData = Awaited<ReturnType<typeof getSmsStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmsStatus>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Sms Status
 */

export function useGetSmsStatus<TData = Awaited<ReturnType<typeof getSmsStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSmsStatus>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSmsStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Setup SMS MFA for authenticated user who wants to enable SMS.
Sends verification code to provided phone number.
 * @summary Authenticated Setup Sms Mfa
 */
export const authenticatedSetupSmsMfa = (
    params: AuthenticatedSetupSmsMfaParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<SMSSetupResponse>(
      {url: `/auth/authenticated/setup-sms-mfa`, method: 'POST',
        params, signal
    },
      );
    }
  


export const getAuthenticatedSetupSmsMfaMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticatedSetupSmsMfa>>, TError,{params: AuthenticatedSetupSmsMfaParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authenticatedSetupSmsMfa>>, TError,{params: AuthenticatedSetupSmsMfaParams}, TContext> => {

const mutationKey = ['authenticatedSetupSmsMfa'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticatedSetupSmsMfa>>, {params: AuthenticatedSetupSmsMfaParams}> = (props) => {
          const {params} = props ?? {};

          return  authenticatedSetupSmsMfa(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticatedSetupSmsMfaMutationResult = NonNullable<Awaited<ReturnType<typeof authenticatedSetupSmsMfa>>>
    
    export type AuthenticatedSetupSmsMfaMutationError = HTTPValidationError

    /**
 * @summary Authenticated Setup Sms Mfa
 */
export const useAuthenticatedSetupSmsMfa = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticatedSetupSmsMfa>>, TError,{params: AuthenticatedSetupSmsMfaParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authenticatedSetupSmsMfa>>,
        TError,
        {params: AuthenticatedSetupSmsMfaParams},
        TContext
      > => {

      const mutationOptions = getAuthenticatedSetupSmsMfaMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Enable SMS MFA by verifying code sent via SMS for authenticated user.
This activates SMS MFA for the user.

Rate limited to 5 attempts - after that user must start setup again.
 * @summary Authenticated Enable Sms Mfa
 */
export const authenticatedEnableSmsMfa = (
    params: AuthenticatedEnableSmsMfaParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AuthenticatedEnableSmsMfa201>(
      {url: `/auth/authenticated/enable-sms-mfa`, method: 'POST',
        params, signal
    },
      );
    }
  


export const getAuthenticatedEnableSmsMfaMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticatedEnableSmsMfa>>, TError,{params: AuthenticatedEnableSmsMfaParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authenticatedEnableSmsMfa>>, TError,{params: AuthenticatedEnableSmsMfaParams}, TContext> => {

const mutationKey = ['authenticatedEnableSmsMfa'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authenticatedEnableSmsMfa>>, {params: AuthenticatedEnableSmsMfaParams}> = (props) => {
          const {params} = props ?? {};

          return  authenticatedEnableSmsMfa(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthenticatedEnableSmsMfaMutationResult = NonNullable<Awaited<ReturnType<typeof authenticatedEnableSmsMfa>>>
    
    export type AuthenticatedEnableSmsMfaMutationError = HTTPValidationError

    /**
 * @summary Authenticated Enable Sms Mfa
 */
export const useAuthenticatedEnableSmsMfa = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authenticatedEnableSmsMfa>>, TError,{params: AuthenticatedEnableSmsMfaParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authenticatedEnableSmsMfa>>,
        TError,
        {params: AuthenticatedEnableSmsMfaParams},
        TContext
      > => {

      const mutationOptions = getAuthenticatedEnableSmsMfaMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    